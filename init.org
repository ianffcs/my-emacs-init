#+TITLE: Ian Emacs config
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview inlineimages
* Meta
#+BEGIN_SRC emacs-lisp
  ;;;; Initialization
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
           (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
       ;   (byte-compile-file (concat user-emacs-directory "init.el"))
      )))

   (add-hook 'after-save-hook 'tangle-init)
#+END_SRC
* Beginning
#+BEGIN_SRC emacs-lisp


;(eval-when-compile
; (setq use-package-expand-minimally byte-compile-current-file))
;; ;;-----------------
  ;; -----------------------------------------------------------
  ;; Adjust garbage collection thresholds during startup, and thereafter
  ;;----------------------------------------------------------------------------
  ;; (let ((normal-gc-cons-threshold (* 20 1024 1024))
  ;;       (init-gc-cons-threshold (* 128 1024 1024)))
  ;;   (setq gc-cons-threshold init-gc-cons-threshold)
  ;;   (add-hook 'emacs-startup-hook
;;             (lambda () (setq gc-cons-threshold normal-gc-cons-threshold))))

(defvar current-user
  (getenv
   (if (equal system-type 'windows-nt) "USERNAME" "USER")))

(message "Let the coding begin! Be patient, %s!" current-user)

;; Always load newest byte code
(setq load-prefer-newer t)


;; reduce the frequency of garbage collection by making it happen on
;; each 50MB of allocated data (the default is on every 0.76MB)
(setq gc-cons-threshold 50000000)

;; warn when opening files bigger than 100MB
(setq large-file-warning-threshold 100000000)
#+END_SRC
* Repos
#+BEGIN_SRC emacs-lisp
  ;;;; Packaging
  (setq package-enable-at-startup nil)
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
               ("marmalade" . "https://marmalade-repo.org/packages/")
               ;;("melpa-stable" . "https://stable.melpa.org/packages/")
               ("tromey" . "http://tromey.com/elpa/")
               ("melpa" . "https://melpa.org/packages/")
               ("org" . "https://orgmode.org/elpa/")))

  (package-initialize)

  ;;;; use-package
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))

  (setq use-package-always-ensure t)

;; auto-package-update
(use-package auto-package-update
  :config
  (auto-package-update-maybe)
  (setq auto-package-update-delete-old-versions t))
#+END_SRC
* Custom
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name (concat user-emacs-directory "custom/custom.el")))
(load custom-file)
#+END_SRC
* Private
#+BEGIN_SRC emacs-lisp
(defconst private-dir (expand-file-name "private" user-emacs-directory))
(defconst temp-dir (format "%s/cache" private-dir))

(unless (file-exists-p private-dir)
  (make-directory private-dir :parents))

(unless (file-exists-p temp-dir)
  (make-directory temp-dir :parents))
#+END_SRC
* Mac custom keyboard
#+BEGIN_SRC emacs-lisp
  (defun paste-from-osx ()
    (shell-command-to-string "pbpaste"))

  (defun copy-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
    (process-send-string proc text)
    (process-send-eof proc))))

  ;; Check the system
  (when (eq system-type 'darwin)
    (setq ;interprogram-cut-function 'copy-to-osx
            ;interprogram-paste-function 'paste-from-osx
            mac-emulate-three-button-mouse nil
            mac-option-modifier 'command
            mac-command-modifier 'meta
            mac-right-command-modifier 'meta
            mac-right-option-modifier 'control
            ;mac-option-key-is-control t
  ))

#+END_SRC
* Linux specific settings
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
 :config
 (when (eq system-type 'gnu/linux)
  (exec-path-from-shell-initialize)))
#+END_SRC
* Exec-path updates
#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (setenv "NODE_VERSION"									 ;;
;;         (concat "/home/ianffcs/.nvm/versions/node/"						 ;;
;;                 (substring (shell-command-to-string "/usr/bin/node --version") 0 -1) "/bin")) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (setq exec-path                  ;;
;;       (nconc exec-path (getenv "NODE_VERSION"))) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(setq exec-path
      (append exec-path '("/home/ianffcs/.nvm/versions/node/v12.11.1/bin")))
#+END_SRC
* Editor confs
#+BEGIN_SRC emacs-lisp

(setq ring-bell-function 'ignore)

(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance

;; Newline at end of file
(setq require-final-newline t)

;; revert buffers automatically when underlying files are changed externally
(global-auto-revert-mode t)


;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))

  ;; smart tab behavior - indent or complete
(setq tab-always-indent 'complete)


(use-package flyspell
  :config
  (setq flyspell-mode +1)
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra")))

(use-package whitespace;; keep the whitespace decent all the time in this buffer
  :config
  (add-hook 'before-save-hook 'prelude-cleanup-maybe nil t)
  (whitespace-mode +1))

(setq ediff-window-setup-function 'ediff-setup-windows-plain)

;; clean up obsolete buffers automatically
(use-package midnight)

(defmacro with-region-or-buffer (func)
  "When called with no active region, call FUNC on current buffer."
  `(defadvice ,func (before with-region-or-buffer activate compile)
     (interactive
      (if mark-active
          (list (region-beginning) (region-end))
        (list (point-min) (point-max))))))

(with-region-or-buffer indent-region)
(with-region-or-buffer untabify)
#+END_SRC
* Persistent-scratch
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC
* Async
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
(setq backup-by-copying 1      ; don't clobber symlinks
      ;; store all backup and autosave files in the tmp dir
      backup-directory-alist  `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
                                        ; use versioned backups
      delete-old-versions 1
      kept-new-versions 6
      kept-old-versions 2
      version-control 1)

(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-mode +1))
#+END_SRC
* Undo Tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :bind (("C-x u" . undo-tree-visualize)
         ("C-_" . undo)
         ("M-_" . undo-tree-redo))
  :config ;; autosave the undo-tree history
  (progn
   (setq undo-tree-history-directory-alist `((".*" . ,temporary-file-directory))
         undo-tree-auto-save-history t)
   (global-undo-tree-mode 1)))
#+END_SRC
* Interface tweaks
#+BEGIN_SRC emacs-lisp
(use-package beacon
    :ensure t
    :config
    (beacon-mode 1))

(use-package smooth-scrolling
  :config (smooth-scrolling-mode 1))
            ; expand the marked region in semantic increments (negative prefix to reduce region)
                    ; expand the marked region in semantic increments (negative prefix to reduce region)
(use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "C-=") 'er/expand-region))

                    ; deletes all the whitespace when you hit backspace or delete
(use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))

(use-package origami
  :ensure t)

(global-origami-mode)

      ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
    ;; This would override `fill-column' if it's an integer.
    (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
   logical line.  This is useful, e.g., for use with `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))

(use-package mode-icons
  :config (mode-icons-mode))

(use-package nyan-mode
  :ensure t
  :init
  (setq nyan-animate-nyancat t
    nyan-wavy-trail t
    mode-line-format
    (list '(:eval (list (nyan-create)))))
  (nyan-mode t))

(use-package parrot
  :config
  (global-set-key (kbd "C-c p") 'parrot-rotate-prev-word-at-point)
  (global-set-key (kbd "C-c n") 'parrot-rotate-next-word-at-point)
  (parrot-set-parrot-type 'science)
  (parrot-mode)
  (add-hook 'before-save-hook 'parrot-start-animation))

(use-package which-key
  :ensure t
  :config (which-key-mode))

(defalias 'yes-or-no-p 'y-or-n-p)
;; before save clears whitespace
(add-hook 'before-save-hook 'whitespace-cleanup)

(fset 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "<f5>") 'revert-buffer)

(global-set-key (kbd "C-c i") 'string-inflection-all-cycle)

(use-package emojify)

(use-package hl-todo
  :config
  (global-hl-todo-mode 1))
#+END_SRC
* Themes
** UTF-8
#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(set-terminal-coding-system  'utf-8)   ; pretty
(set-keyboard-coding-system  'utf-8)   ; pretty
(set-selection-coding-system 'utf-8)   ; please
(prefer-coding-system        'utf-8)   ; with sugar on top
(setq default-process-coding-system '(utf-8-unix . utf-8-unix)
      locale-coding-system          'utf-8)
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (when window-system            ;;
;;       (use-package pretty-mode ;;
;;       :ensure t                ;;
;;       :config                  ;;
;;       (global-pretty-mode t))) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(when window-system
  (global-prettify-symbols-mode))

;; (defconst my-default-font "-*-fixed-medium-r-normal-*-15-*-*-*-*-*-*-*")
  ;; (defconst my-default-font "-misc-fixed-*-*-*-*-12-*-*-*-*-*-*-*")
  ;; (defconst my-default-font "-b&h-lucidatypewriter-medium-r-normal-sans-14-*-*-*-*-*-iso8859-1")
  ;; (defconst my-default-font "FantasqueSansMono Nerd Font-10")
  ;; (defconst my-default-font "Monoid-9")
  ;; (defconst my-default-font "Fixed-10")
  ;;(defconst my-default-font "Dina-10")
  ;; (defconst my-default-font "Iosevka-9")
  ;; (defconst my-default-font "Terminus-10")
(defconst my-default-font "Fira Code-10")
;; (defconst my-default-font "Hack-10")


(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))

(defconst fira-code-mode--ligatures
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "x" ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))
#+END_SRC
** Visual
#+BEGIN_SRC emacs-lisp
(defconst my-frame-alist
  `((font                 . ,my-default-font)
    (scroll-bar           . -1)
    (height               . 60)
    (width                . 95)
    (alpha                . 95)
    (vertical-scroll-bars . nil)))

(setq default-frame-alist my-frame-alist)

(use-package all-the-icons
     :ensure t)

(use-package doom-themes
     :ensure t
     :init (setq doom-themes-enable-bold t doom-themes-enable-italic t)
     :config
     (doom-themes-org-config)
; (doom-themes-treemacs-config)
     (load-theme 'doom-one t))

(setq inhibit-startup-screen        t
      inhibit-splash-screen         t
      line-number-mode              1
      column-number-mode            1
      show-paren-mode               1
      show-paren-delay              0
      blink-cursor-mode             nil
      transient-mark-mode           1
      scroll-bar-mode               -1
      browser-url-browse-function   'browse-url-firefox
      linum-format                  "%5d"
      tab-width                     4
      global-hl-line-mode           t
      indent-tabs-mode              nil
      truncate-partial-width-windows 1
      fill-column                   80
      truncate-lines                1
      save-interprogram-paste-before-kill t
      ;; Mouse
      transentient-mark-mode        t
      mouse-wheel-follow-mouse      t
      scroll-step                   1
      scroll-conservatively         101
      mouse-wheel-scroll-amount     '(1)
      mouse-wheel-progressive-speed nil)

  (menu-bar-mode -1)
  (tool-bar-mode -1)

(set-cursor-color "#ffffff")

     (defun custom-set-frame-size ()
       (add-to-list 'default-frame-alist '(height . 50))
       (add-to-list 'default-frame-alist '(width . 178)))
     (custom-set-frame-size)
     (add-hook 'before-make-frame-hook 'custom-set-frame-size)

     (use-package rainbow-delimiters
       :ensure t
       :config
       (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'common-lisp-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'scheme-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode)
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

   (add-hook 'prog-mode-hook 'linum-mode)

   (defun set-frame-alpha (value)
     "Set the transparency of the frame. 0 = transparent/100 = opaque"
     (interactive "Alpha value (0-100): ")
     (set-frame-parameter (selected-frame) 'alpha value))

   (set-frame-alpha 90)
#+END_SRC
* Completion Framework Ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind
  (("M-x" . counsel-M-x)
   ("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)
   ("C-x C-f" . counsel-find-file))
  :config       (define-key read-expression-map (kbd "C-r") 'counsel-expression-history))

(use-package smex)

(use-package ivy
  :diminish (ivy-mode)
  :bind (("C-x b" . ivy-switch-buffer)
         ("C-c C-r" . ivy-resume))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "%d/%d ")
  (setq ivy-display-style 'fancy))

(use-package swiper
  :bind (("C-s" . swiper-isearch))
  :config
  (ivy-mode 1))

(use-package anzu
  :config
  (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
#+END_SRC
* IBuffer
#+BEGIN_SRC emacs-lisp
(use-package ibuffer-tramp)

(use-package ibuffer-projectile)

(use-package ibuffer-git)

(use-package ibuffer-sidebar
  :commands (ibuffer-sidebar-toggle-sidebar)
  :config
  (setq ibuffer-sidebar-use-custom-font t)
  (setq ibuffer-sidebar-face `(:family "Helvetica" :height 140)))

(defun sidebar-toggle ()
  "Toggle both `dired-sidebar' and `ibuffer-sidebar'."
  (interactive)
  (dired-sidebar-toggle-sidebar)
  (ibuffer-sidebar-toggle-sidebar))
#+END_SRC
* Dired
#+BEGIN_SRC emacs-lisp
;; dired - reuse current buffer by pressing 'a'
(put 'dired-find-alternate-file 'disabled nil)

;; always delete and copy recursively
(setq dired-recursive-deletes 'always)
(setq dired-recursive-copies 'always)

;; if there is a dired buffer displayed in the next window, use its
;; current subdir, instead of the current subdir of this dired buffer
(setq dired-dwim-target t)

(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :ensure t
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
            (lambda ()
              (unless (file-remote-p default-directory)
                (auto-revert-mode))))
  :config
  (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
  (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

  (setq dired-sidebar-subtree-line-prefix "__"
        dired-sidebar-use-term-integration t
        dired-sidebar-use-custom-font t)
  ;(setq dired-sidebar-theme 'vscode)
  )

(defun +sidebar-toggle ()
  "Toggle both `dired-sidebar' and `ibuffer-sidebar'."
  (interactive)
  (dired-sidebar-toggle-sidebar)
  (ibuffer-sidebar-toggle-sidebar))
#+END_SRC
* Window Manager
Everything regarding the WM or DE-like functionality is bundled here, remove the entire section if you do not wish to use =exwm=.
** exwm
The only time I actually had to use comments, this is for ease of removal if you happen to not like exwm.
*** Installation
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :config

      ;; necessary to configure exwm manually
      (require 'exwm-config)

      ;; fringe size, most people prefer 1
      (fringe-mode 3)

      ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
      (server-start)

      ;; this fixes issues with ido mode, if you use helm, get rid of it
      ;;(exwm-config-ido)

      ;; a number between 1 and 9, exwm creates workspaces dynamically so I like starting out with 1
      (setq exwm-workspace-number 1)

      ;; this is a way to declare truly global/always working keybindings
      ;; this is a nifty way to go back from char mode to line mode without using the mouse
      (exwm-input-set-key (kbd "s-r") #'exwm-reset)
      (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
      (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)

      ;; the next loop will bind s-<number> to switch to the corresponding workspace
      (dotimes (i 10)
        (exwm-input-set-key (kbd (format "s-%d" i))
                            `(lambda ()
                               (interactive)
                               (exwm-workspace-switch-create ,i))))

      ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
      (exwm-input-set-key (kbd "s-&")
                          (lambda (command)
                            (interactive (list (read-shell-command "$ ")))
                            (start-process-shell-command command nil command)))

      ;; an easy way to make keybindings work *only* in line mode
      (push ?\C-q exwm-input-prefix-keys)
      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

      ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
      (exwm-input-set-simulation-keys
       '(
         ;; movement
         ([?\C-b] . left)
         ([?\M-b] . C-left)
         ([?\C-f] . right)
         ([?\M-f] . C-right)
         ([?\C-p] . up)
         ([?\C-n] . down)
         ([?\C-a] . home)
         ([?\C-e] . end)
         ([?\M-v] . prior)
         ([?\C-v] . next)
         ([?\C-d] . delete)
         ([?\C-k] . (S-end delete))
         ;; cut/paste
         ([?\C-w] . ?\C-x)
         ([?\M-w] . ?\C-c)
         ([?\C-y] . ?\C-v)
         ;; search
         ([?\C-s] . ?\C-f)))

      ;; this little bit will make sure that XF86 keys work in exwm buffers as well
      (dolist (k '(XF86AudioLowerVolume
                 XF86AudioRaiseVolume
                 XF86PowerOff
                 XF86AudioMute
                 XF86AudioPlay
                 XF86AudioStop
                 XF86AudioPrev
                 XF86AudioNext
                 XF86ScreenSaver
                 XF68Back
                 XF86Forward
                 Scroll_Lock
                 print))
      (cl-pushnew k exwm-input-prefix-keys))

      ;; this just enables exwm, it started automatically once everything is ready
      (exwm-enable))
#+END_SRC

** Launchers
Since I do not use a GUI launcher and do not have an external one like dmenu or rofi,
I figured the best way to launch my most used applications would be direct emacsy
keybindings.

*** dmenu for emacs
Who would've thought this was available, together with ido-vertical it's a nice large menu
with its own cache for most launched applications.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind
      ("s-SPC" . 'dmenu))
#+END_SRC

*** Functions to start processes
I guess this goes without saying but you absolutely have to change the arguments
to suit the software that you are using. What good is a launcher for discord if you don't use it at all.
#+BEGIN_SRC emacs-lisp
  (defun exwm-async-run (name)
    (interactive)
    (start-process name nil name))

  (defun daedreth/launch-discord ()
    (interactive)
    (exwm-async-run "discord"))

  (defun daedreth/launch-telegram ()
    (interactive)
    (exwm-async-run "telegram-desktop"))

  (defun daedreth/launch-browser ()
    (interactive)
    (exwm-async-run "qutebrowser"))

  (defun daedreth/lock-screen ()
    (interactive)
    (exwm-async-run "slock"))

  (defun daedreth/shutdown ()
    (interactive)
    (start-process "halt" nil "sudo" "halt"))
#+END_SRC

*** Keybindings to start processes
These can be modified as well, suit yourself.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-d") 'daedreth/launch-discord)
  (global-set-key (kbd "s-l") 'daedreth/lock-screen)
  (global-set-key (kbd "<s-tab>") 'daedreth/launch-browser)
  (global-set-key (kbd "<XF86ScreenSaver>") 'daedreth/lock-screen)
  (global-set-key (kbd "<XF86PowerOff>") 'daedreth/shutdown)
#+END_SRC

** Audio controls
This is a set of bindings to my XF86 keys that invokes pulsemixer with the correct parameters

*** Volume modifier
It goes without saying that you are free to modify the modifier as you see fit, 4 is good enough for me though.
#+BEGIN_SRC emacs-lisp
(defconst volumeModifier "4")
#+END_SRC

*** Functions to start processes
#+BEGIN_SRC emacs-lisp
  (defun audio/mute ()
    (interactive)
    (start-process "audio-mute" nil "pulsemixer" "--toggle-mute"))

  (defun audio/raise-volume ()
    (interactive)
    (start-process "raise-volume" nil "pulsemixer" "--change-volume" (concat "+" volumeModifier)))

  (defun audio/lower-volume ()
    (interactive)
    (start-process "lower-volume" nil "pulsemixer" "--change-volume" (concat "-" volumeModifier)))
#+END_SRC

*** Keybindings to start processes
You can also change those if you'd like, but I highly recommend keeping 'em the same, chances are, they will just work.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
(global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
(global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_SRC

** Screenshots
I don't need scrot to take screenshots, or shutter or whatever tools you might have. This is enough.
These won't work in the terminal version or the virtual console, obvious reasons.

*** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot ()
    "Takes a fullscreen screenshot of the current workspace"
    (interactive)
    (when window-system
    (loop for i downfrom 3 to 1 do
          (progn
            (message (concat (number-to-string i) "..."))
            (sit-for 1)))
    (message "Cheese!")
    (sit-for 1)
    (start-process "screenshot" nil "import" "-window" "root"
               (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (message "Screenshot taken!")))
  (global-set-key (kbd "<print>") 'daedreth/take-screenshot)
#+END_SRC

*** Screenshotting a region
#+BEGIN_SRC emacs-lisp
  (defun daedreth/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
  (global-set-key (kbd "<Scroll_Lock>") 'daedreth/take-screenshot-region)
#+END_SRC

** Default browser
I use qutebrowser, so that's what I'll set up.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")
#+END_SRC
** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs, otherwise the built in battery-mode will be used.
Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
      (setq fancy-battery-show-percentage t)
      (setq battery-update-interval 15)
      (if window-system
        (fancy-battery-mode)
        (display-battery-mode)))
#+END_SRC

** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

symon can be toggled on and off with =Super + h=.
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("s-h" . symon-mode))
#+END_SRC

** Default Shell
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-zsh)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC
* Smartparens & Parens-thing
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish
  :init
  (define-key smartparens-mode-map (kbd "M-(") 'sp-wrap-round)
  (define-key smartparens-mode-map (kbd "M-[") 'sp-wrap-square)
  (define-key smartparens-mode-map (kbd "M-{") 'sp-wrap-curly)
  (define-key smartparens-mode-map (kbd "C-c (") 'sp-unwrap-sexp)
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1)
  (sp-local-pair '(emacs-lisp-mode) "'" "'" :actions nil)
  (sp-local-pair '(common-lisp-mode) "'" "'" :actions nil)
  (sp-local-pair '(clojure-mode) "'" "'" :actions nil)
  (sp-local-pair '(cider-repl-mode) "'" "'" :actions nil)
  (sp-local-pair '(scheme-mode) "'" "'" :actions nil)
  (sp-local-pair '(lisp-mode) "'" "'" :actions nil)
  (setq smartparens-global-strict-mode 1))

(use-package highlight-parentheses)

(use-package highlight-sexp)

  #+END_SRC
* Movin' around baby
** split-switch
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))

  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)

(use-package ace-window
  :config
  (global-set-key (kbd "M-o") 'ace-window)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))

(use-package windmove
  :config
  (windmove-default-keybindings))

;; avy allows us to effectively navigate to visible things
(use-package avy
  :bind ("M-s" . avy-goto-char)
  :config
  (setq avy-background t
          avy-style 'at-full))
#+END_SRC

** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!
#+BEGIN_SRC emacs-lisp
  (use-package mark-multiple
    :ensure t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC
** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/kill-inner-word ()
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC

** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
        (point-at-bol)
        (point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'daedreth/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC
** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC
** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
A lot more useful than you might think. If you wish to include the selected character in the killed region,
change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC
* buffers stuff
** Always murder current buffer
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

# ** Kill buffers without asking for confirmation
# #+BEGIN_SRC emacs-lisp
# (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
# #+END_SRC

** Turn switch-to-buffer into ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("dired" (mode . dired-mode))
               ("org" (name . "^.*org$"))
               ("magit" (mode . magit-mode))
               ("IRC" (or (mode . circe-channel-mode) (mode . circe-server-mode)))
               ("web" (or (mode . web-mode) (mode . js2-mode)))
               ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
               ("mu4e" (or (mode . mu4e-compose-mode)
                           (name . "\*mu4e\*")))
               ("programming" (or (mode . clojure-mode)
                                  (mode . clojurescript-mode)
                                  (mode . python-mode)
                                  (mode . c++-mode)))
               ("emacs" (or (name . "^\\*scratch\\*$")
                            (name . "^\\*Messages\\*$")))))))

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-auto-mode 1)
            (ibuffer-switch-to-saved-filter-groups "default")))

(setq ibuffer-show-empty-filter-groups nil)

;; Don't ask for confirmation to delete marked buffers
(setq ibuffer-expert t)
#+END_SRC
*** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
(setq ibuffer-expert t)
#+END_SRC
** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC
* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Autocomplete
#+BEGIN_SRC emacs-lisp  :tangle no
(use-package auto-complete
         :ensure t
         :init
         (progn
           (ac-config-default)
           (global-auto-complete-mode t)))
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode t))
#+END_SRC
* Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))

(use-package auto-yasnippet
  :ensure t)

(use-package yasnippet-snippets
  :after (yas-global-mode))
#+END_SRC
* Langs
** General
*** TODO Prog mode
#+BEGIN_SRC emacs-lisp
(setq sp-base-key-bindings 'paredit)
(setq sp-autoskip-closing-pair 'always)
(setq sp-hybrid-kill-entire-symbol nil)
(sp-use-paredit-bindings)
#+END_SRC
*** Lisp General Mode
#+BEGIN_SRC emacs-lisp
(use-package highlight-sexp)
#+END_SRC
*** Highlight Numbers
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :config (add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC
*** Flycheck confs
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode t)
  :diminish nil)
#+END_SRC
*** Semantic confs
#+BEGIN_SRC emacs-lisp
(require 'semantic)

(global-semanticdb-minor-mode        1)
(global-semantic-idle-scheduler-mode 1)
(global-semantic-stickyfunc-mode     0)

(semantic-mode 1)
#+END_SRC
*** Company confs
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 3)
  (global-company-mode t))

(use-package company-irony
  :ensure t
  :config
  (add-to-list 'company-backends 'company-irony))

(use-package irony
  :ensure t
  :config
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

(use-package irony-eldoc
  :ensure t
  :config
  (add-hook 'irony-mode-hook #'irony-eldoc))

  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
  ;; (use-package company-jedi
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'python-mode-hook 'jedi:setup))

  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
#+END_SRC
*** Aggressive Indent
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent)
#+END_SRC
*** NVM
#+BEGIN_SRC emacs-lisp
(use-package nvm)
#+END_SRC
*** LSP Mode
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :hook (;;(clojure-mode . lsp)
         (haskell-mode . lsp))
  ;;   :custom
  ;;   ((lsp-clojure-server-command '("java" "-jar" "/home/ianffcs/Downloads/clj-kondo-lsp-server-2020.01.27-standalone.jar")))
  ;;   :config
  ;;   (dolist (m '(clojure-mode
  ;;                clojurescript-mode))
  ;;     (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
  :commands lsp)

(use-package lsp-ui
  :ensure t
  :commands lsp-ui-mode)
#+END_SRC
** By Lang Configuration
*** Agda
#+BEGIN_SRC emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+END_SRC
*** Bash
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
*** Clisp
#+BEGIN_src emacs-lisp
(use-package slime
  :hook ((slime-mode . smartparens-strict-mode)
         (slime-mode . rainbow-parens-mode)
         (slime-mode . highlight-parentheses-mode))
  :mode
  ("\\.lisp$" . slime-mode)
  :init
  (setq inferior-lisp-program "/usr/bin/sbcl"
        slime-net-coding-system 'utf-8-unix
        slime1-contribs '(slime-fancy)))

#+END_SRC
*** Elisp
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
(add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
(add-hook 'emacs-lisp-mode-hook #'highlight-parentheses-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'rainbow-delimiters-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'highlight-parentheses-mode)
(add-hook 'ielm-mode-hook             #'smartparens-strict-mode)
(add-hook 'ielm-mode-hook             #'rainbow-delimiters-mode)
(add-hook 'ielm-mode-hook #'highlight-parentheses-mode)
(add-hook 'lisp-mode-hook             #'smartparens-strict-mode)
(add-hook 'lisp-mode-hook             #'rainbow-delimiters-mode)
(add-hook 'lisp-mode-hook #'highlight-parentheses-mode)
(add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
(add-hook 'lisp-interaction-mode-hook #'rainbow-delimiters-mode)
(add-hook 'lisp-interaction-mode-hook #'highlight-parentheses-mode)
(add-hook 'scheme-mode-hook           #'smartparens-strict-mode)
(add-hook 'scheme-mode-hook           #'rainbow-delimiters-mode)
(add-hook 'scheme-mode-hook #'highlight-parentheses-mode)
(add-hook 'emacs-lisp-mode-hook  #'highlight-sexp-mode)
;; eldoc-mode shows documentation in the minibuffer when writing code
;; http://www.emacswiki.org/emacs/ElDoc
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

(defun ielm-auto-complete ()
  "Enables `auto-complete' support in \\[ielm]."
  (setq ac-sources '(ac-source-functions
                     ac-source-variables
                     ac-source-features
                     ac-source-symbols
                     ac-source-words-in-same-mode-buffers))
  (auto-complete-mode 1))

(defun ielm/clear-repl ()
  "Clear current REPL buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (ielm-send-input)))
#+END_SRC
*** Clojure
 #+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)

(use-package clojure-mode-extra-font-locking)

(defun prettify-anonymous-fns ()
  (font-lock-add-keywords
   nil `(("\\(#\\)("
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(make-char 'greek-iso8859-7 107))
                    nil))))))

(defun prettify-sets ()
  (font-lock-add-keywords
   nil `(("\\(#\\){"
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    "∈")
                    nil))))))

(defun prettify-some-chars ()
  (dolist (x '((true        т)
               (false       ғ)
               (:keys       ӄ)
               (:strs       ş)
               (nil         Ø)
               (partial     Ƥ)
               (with-redefs я)
               (comp        º)
               (apply       ζ)
               (a-fn1       α)
               (a-fn2       β)
               (a-fn3       γ)
               (no-op       ε)))
    (font-lock-add-keywords
     nil `((,(concat "[\[({[:space:]]"
                               "\\(" (symbol-name (first x)) "\\)"
                               "[\])}[:space:]]")
                      (0 (progn (compose-region (match-beginning 1)
                                                (match-end 1) ,(symbol-name (second x)))
                                nil)))))
    (font-lock-add-keywords
     nil `((,(concat "^"
                     "\\(" (symbol-name (first x)) "\\)"
                     "[\])}[:space:]]")
            (0 (progn (compose-region (match-beginning 1)
                                      (match-end 1) ,(symbol-name (second x)))
                      nil)))))
    (font-lock-add-keywords
     nil `((,(concat "[\[({[:space:]]"
                                "\\(" (symbol-name (first x)) "\\)"
                                "$")
                       (0 (progn (compose-region (match-beginning 1)
                                                 (match-end 1) ,(symbol-name (second x)))
                                 nil)))))))

(use-package clojure-mode
  :hook ((clojure-mode . aggressive-indent-mode)
         (clojure-mode . smartparens-strict-mode)
         (clojure-mode . subword-mode)
         (clojure-mode . cider-mode)
         (clojure-mode . clj-refactor-mode)
         (clojure-mode . rainbow-delimiters-mode)
         (clojure-mode . highlight-sexp-mode)
         (clojure-mode . highlight-parentheses-mode)
         (clojure-mode . prettify-anonymous-fns)
         (clojure-mode . prettify-sets)
         (clojure-mode . prettify-some-chars))
  :config
  (progn
    (eval-after-load 'clojure-mode
      '(define-clojure-indent
         (train-n 3)
         (for-all 1)
         (fdef 1)
         (mlet 1)
         (alet 1)
         ;;(async 1)
         (defapi '(2 nil nil (1)))
         (server 2)
         (sniptest 1)
         (reg-event-db 1)
         (reg-sub 1)
         (reg-sub-raw 1)
         (reg-event-fx 1)
         (reg-fx 1)
         (reg-cofx 1)
         (at-media 1)
         (GET 2)
         (not-join 1)
         (recursive-path 2)
         (wcar 1)
         (implement '(1 (1)))
         (letfn     '(1 ((:defn)) nil))
         (proxy     '(2 nil nil (1)))
         (reify     '(:defn (1)))
         (deftype   '(2 nil nil (1)))
         (defrecord '(2 nil nil (1)))
         (specify   '(1 (1)))))
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (hack-local-variables)
    (setq clojure-align-forms-automatically 1)))

(use-package clojurescript-mode
  :hook ((clojurescript-mode . aggressive-indent-mode)
         (clojurescript-mode . smartparens-strict-mode)
         (clojurescript-mode . subword-mode)
         (clojurescript-mode . cider-mode)
         (clojurescript-mode . clj-refactor-mode)
         (clojurescript-mode . rainbow-delimiters-mode)
         (clojurescript-mode . highlight-sexp-mode)
         (clojurescript-mode . highlight-parentheses-mode)
         (clojurescript-mode . prettify-fns)
         (clojurescript-mode . prettify-anonymous-fns)
         (clojurescript-mode . prettify-sets))
  :config
  (progn
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (hack-local-variables)
    (setq clojure-align-forms-automatically 1)))

(defun cider-repl-prompt-custom (namespace)
  "Return a prompt string that mentions NAMESPACE."
  (format "λ %s λ\n" namespace))

(use-package cider
  :hook ((cider-repl-mode . subword-mode)
         (cider-repl-mode . company-mode)
         (cider-repl-mode . smartparens-strict-mode)
         (cider-mode . smartparens-strict-mode)
         (cider-mode . rainbow-delimiters-mode)
         (cider-mode . highlight-parentheses-mode)
         (cider-mode . cider-company-enable-fuzzy-completion))
  :bind (:map
         cider-mode-map
         ("C-c C-d" . cider-debug-defun-at-point)
         :map
         cider-repl-mode-map
         ("C-c M-o" . cider-repl-clear-buffer))
  :config
  (progn
    (setq cider-repl-pop-to-buffer-on-connect nil
          cider-repl-use-clojure-font-lock nil
          cider-annotate-completion-candidates t
          cider-prompt-for-symbol nil
          cider-repl-use-pretty-printing t
          cider-repl-wrap-history t
          cider-repl-pop-to-buffer-on-connect 'display-only
          cider-repl-prompt-function 'cider-repl-prompt-custom
          cider-repl-result-prefix ";; => "
          cider-repl-display-in-current-window t
          cider-repl-wrap-history t
          cider-repl-use-pretty-printing 't
          cider-pprint-fn 'puget
          cider-print-options '(("print-color" "true"))
          cider-repl-use-clojure-font-lock t
          cider-auto-select-error-buffer nil
          org-babel-clojure-backend 'cider
          cider-eldoc-display-context-dependent-info t
          cider-save-file-on-load t
          cider-jump-to-pop-to-buffer-actions '((display-buffer-same-window))
          ;; emidje-load-facts-on-eval t
          )
    (define-key clojure-mode-map (kbd "C-t") 'cider-test-rerun-test)
    )
  ;; (eval-after-load 'cider #'emidje-enable-nrepl-middleware)
  )


(use-package clj-refactor
  :config (progn (setq cljr-suppress-middleware-warnings t)
                 (add-hook 'clojure-mode-hook (lambda ()
                                                (clj-refactor-mode 1)
                                                (yas-minor-mode 1)
                                                (cljr-add-keybindings-with-prefix "C-c C-m")))))

(use-package flycheck-joker
  :after clojure-mode
  :ensure t)

(use-package flycheck-clj-kondo
  :ensure t
  :after clojure-mode
  :config
  (dolist (checkers '((clj-kondo-clj . clojure-joker)
                      (clj-kondo-cljs . clojurescript-joker)
                      (clj-kondo-cljc . clojure-joker)
                      (clj-kondo-edn . edn-joker)))
    (flycheck-add-next-checker (car checkers) (cons 'error (cdr checkers)))))

;(use-package emidje
 ; :config (eval-after-load 'cider #'emidje-setup))

(use-package kaocha-runner
  :config
  (define-key clojure-mode-map (kbd "C-c k t") 'kaocha-runner-run-test-at-point)
  (define-key clojure-mode-map (kbd "C-c k r") 'kaocha-runner-run-tests)
  (define-key clojure-mode-map (kbd "C-c k a") 'kaocha-runner-run-all-tests)
  (define-key clojure-mode-map (kbd "C-c k w") 'kaocha-runner-show-warnings)
  (define-key clojure-mode-map (kbd "C-c k h") 'kaocha-runner-hide-windows))

(use-package ac-cider
  :config
  (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
  (add-hook 'cider-mode-hook 'ac-cider-setup)
  (eval-after-load "auto-complete"
    '(add-to-list 'ac-modes 'cider-repl-mode)))

(defun set-auto-complete-as-completion-at-point-function ()
  (setq completion-at-point-functions '(auto-complete)))

(use-package clojure-snippets
  :ensure t
  :defer t)


(add-hook 'auto-complete-mode-hook 'set-auto-complete-as-completion-at-point-function)
(add-hook 'cider-repl-mode-hook 'set-auto-complete-as-completion-at-point-function)
(add-hook 'cider-mode-hook 'set-auto-complete-as-completion-at-point-function)
#+END_SRC
*** Kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)

(use-package flycheck-kotlin)

(use-package ob-kotlin)
#+END_SRC
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode ("\\Dockerfile$" . dockerfile-mode))

(use-package docker-compose-mode)
#+END_SRC
*** Elixir
#+BEGIN_SRC emacs-lisp
(defun format-elixir-buffer ()
  "Format elixir buffer."
  (add-hook 'before-save-hook 'elixir-format nil t))

(use-package elixir-mode
  :hook ((elixir-mode . format-elixir-buffer)
         (elixir-mode . flycheck-mix-setup))
  :mode (("\\.ex$" . elixir-mode)
         ("\\.exs$" . elixir-mode)))

(use-package alchemist
  :hook (elixir-mode . alchemist-mode))

(use-package flycheck-mix)
#+END_SRC
*** Nginx
#+BEGIN_SRC emacs-lisp
(use-package nginx-mode)
#+END_SRC
*** Python
#+BEGIN_SRC emacs-lisp
(use-package python
  :mode ("\\.py" . python-mode)
  :config (setq python-shell-interpreter "python3"
                py-python-command "python3"))

(use-package elpy
  :hook ((python-mode . elpy-mode)
         (python-mode . elpy-enable))
  :custom
  (elpy-rpc-backend "jedi")
  :bind (:map elpy-mode-map
              ("M-." . elpy-goto-definition)
              ("M-," . pop-tag-mark)
              ("<M-left>" . nil)
              ("<M-right>" . nil)
              ("<M-S-left>" . elpy-nav-indent-shift-left)
              ("<M-S-right>" . elpy-nav-indent-shift-right)
              ("C-c i" . elpy-autopep8-fix-code)
              ("C-c C-d" . elpy-doc)))

(use-package pip-requirements
  :hook ((pip-requirements-mode . #'pip-requirements-auto-complete-setup)))

(use-package py-autopep8
  :hook ((python-mode . py-autopep8-enable-on-save)))

(use-package virtualenvwrapper
  :ensure t
  :config
  (venv-initialize-interactive-shells)
  (venv-initialize-eshell))

(use-package pipenv
  :hook (python-mode . pipenv-mode)
  :init
  (setq pipenv-projectile-after-switch-function
        #'pipenv-projectile-after-switch-extended))

;;(use-package ein)

(use-package hy-mode)
#+END_SRC
*** Rust
#+BEGIN_SRC emacs-lisp
  ;; rust-mode
  ;; https://github.com/rust-lang/rust-mode
(use-package rust-mode
  :bind (:map rust-mode-map
              (("C-c C-t" . racer-describe)))
  :config
  (progn
    ;; add flycheck support for rust
    ;; https://github.com/flycheck/flycheck-rust
    (use-package flycheck-rust
      :after rust-mode
      :hook ((rust-mode . flycheck-rust-setup)))

    ;; cargo-mode for all the cargo related operations
    ;; https://github.com/kwrooijen/cargo.el
    (use-package cargo
      :hook ((rust-mode . cargo-minor-mode)))

    ;; racer-mode for getting IDE like features for rust-mode
    ;; https://github.com/racer-rust/emacs-racer
    (use-package racer
      :hook ((rust-mode . racer-mode)
             (racer-mode . eldoc-mode))
      :config
      (progn
        ;; set racer rust source path environment variable
        (setq racer-rust-src-path "/home/ianffcs/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src")
        (defun my-racer-mode-hook ()
          (set (make-local-variable 'company-backends)
               '((company-capf company-files))))
        (define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common))

      ;; enable company and eldoc minor modes in rust-mode
      (add-hook 'racer-mode-hook 'company-mode)
      (add-hook 'racer-mode-hook 'eldoc-mode)))
  (add-hook 'rust-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c <tab>") #'rust-format-buffer)))
  (add-hook 'rust-mode-hook 'flycheck-mode)
  (add-hook 'flycheck-mode-hook 'flycheck-rust-setup)
  (add-hook 'rust-mode-hook 'racer-mode)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)

  ;; format rust buffers on save using rustfmt
  (add-hook 'before-save-hook
            (lambda ()
              (when (eq major-mode 'rust-mode)
                (rust-format-buffer)))))
#+END_SRC
*** Haskell
#+BEGIN_SRC emacs-lisp

(use-package lsp-haskell
 :ensure t
 :config
 (setq lsp-haskell-process-path-hie "ghcide"
       lsp-haskell-process-args-hie '())
  ;; Comment/uncomment this line to see interactions between lsp client/server.
 ;; (setq lsp-log-io t)
 )

(use-package haskell-mode
  :ensure t
  :hook (haskell-mode . interactive-haskell-mode))

(use-package eglot
  :ensure t
  :config
  (add-to-list 'eglot-server-programs '(haskell-mode . ("ghcide" "--lsp"))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (use-package intero                                            ;;
;;   :ensure t :config                                            ;;
;;   (progn                                                       ;;
;;     (add-hook 'haskell-mode-hook 'intero-mode)))               ;;
;;                                                                ;;
;; (setq flycheck-check-syntax-automatically '(save new-line))    ;;
;; (flycheck-add-next-checker 'intero '(warning . haskell-hlint)) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+END_SRC
*** WebMode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
  (setq web-mode-engines-alist
        '(("django"    . "\\.html\\'")))
  (setq web-mode-ac-sources-alist
        '(("css" . (ac-source-css-property))
          ("vue" . (ac-source-words-in-buffer ac-source-abbrev))
          ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

(setq web-mode-enable-auto-closing t))
(setq web-mode-enable-auto-quoting t) ; this fixes the quote problem I mentioned
#+END_SRC
*** JS
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :ensure ac-js2
  :init
  (progn
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (add-hook 'js2-mode-hook 'ac-js2-mode)))

(use-package js2-refactor
  :ensure t
  :config
  (progn
    (js2r-add-keybindings-with-prefix "C-c C-m")
;; eg. extract function with `C-c C-m ef`.
    (add-hook 'js2-mode-hook #'js2-refactor-mode)))

(use-package tern
  :ensure tern
  :ensure tern-auto-complete
  :config
  (progn
    (add-hook 'js-mode-hook (lambda () (tern-mode t)))
    (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    ;;(tern-ac-setup)
))

;;(use-package jade
;;:ensure t
;;)

;; use web-mode for .jsx files
(add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))


;; turn on flychecking globally
(add-hook 'after-init-hook #'global-flycheck-mode)

;; disable jshint since we prefer eslint checking
(setq-default flycheck-disabled-checkers
  (append flycheck-disabled-checkers
    '(javascript-jshint)))

;; use eslint with web-mode for jsx files
(flycheck-add-mode 'javascript-eslint 'web-mode)

;; customize flycheck temp file prefix
(setq-default flycheck-temp-prefix ".flycheck")

;; disable json-jsonlist checking for json files
(setq-default flycheck-disabled-checkers
  (append flycheck-disabled-checkers
    '(json-jsonlist)))

;; adjust indents for web-mode to 2 spaces
(defun my-web-mode-hook ()
  "Hooks for Web mode. Adjust indents"
  ;;; http://web-mode.org/
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))

(add-hook 'web-mode-hook  'my-web-mode-hook)

(use-package company-web
  :after web-mode)

(use-package rjsx-mode
  :mode ("\\.jsx$" . rjsx-mode)
  :magic ("%React" . rjsx-mode))

(use-package vue-mode
  :mode
  ("\\.vue$" . vue-mode))

(use-package indium
  :after js2-mode
  :hook ((js2-mode . indium-interaction-mode))
  :bind (:map indium-interaction-mode-map
              ("C-x C-e" . indium-eval-last-node)
              ("C-<f6>" . vs/stop-indium-debug)
              ("S-<f6>" . indium-connect)
              ("<f6>" . indium-launch))
  :config (delight indium-interaction-mode))

(use-package mocha
  :init (setq mocha-reporter "spec")
  :bind (:map js2-mode-map
              (("C-c t" . mocha-test-project))))

(use-package json-mode
  :mode
  ("\\.json$" . json-mode))
#+END_SRC
*** Latex
#+BEGIN_SRC emacs-lisp
  ;; (use-package tex
    ;; :ensure t)

  ;; (use-package cdlatex
  ;;   :ensure t)

  ;; ;;
  ;(use-package auctex
  ;;   :ensure t
  ;;   :config (setq TeX-auto-save t)
  ;;   (setq TeX-parse-self t)
  ;;   (setq TeX-close-quote "")
  ;;   (setq TeX-open-quote ""))


  ;; (defcustom
  ;;   prelude-latex-fast-math-entry 'LaTeX-math-mode
  ;;   "Method used for fast math symbol entry in LaTeX."
  ;;   :link '(function-link :tag "AUCTeX Math Mode" LaTeX-math-mode)
  ;;   :link '(emacs-commentary-link :tag "CDLaTeX" "cdlatex.el")
  ;;   :group 'prelude
  ;;   :type '(choice (const :tag "None" nil)
  ;;                  (const :tag "AUCTeX Math Mode" LaTeX-math-mode)
  ;; (const :tag "CDLaTeX" cdlatex)))

  ;; (defun tex-view ()
  ;;   (interactive)
  ;;   (tex-send-command "evince" (tex-append tex-print-file ".pdf")))

  ;; (require 'latex-pretty-symbols)
  ;; (add-hook 'markdown-mode-hook 'pandoc-mode)
  ;; (add-hook 'markdown-mode-hook 'latex-unicode-simplified)
  ;; (setq markdown-enable-math 1)
  ;; (add-hook 'org-mode-hook 'latex-unicode-simplified)

  ;; (eval-after-load "tex"
  ;;   '(add-to-list 'TeX-command-list '("latexmk" "latexmk -synctex=1 -shell-escape -pdf %s" TeX-run-TeX nil t :help "Process file with latexmk")))
  ;; (eval-after-load "tex"
  ;;   '(add-to-list 'TeX-command-list '("xelatexmk" "latexmk -synctex=1 -shell-escape -xelatex %s" TeX-run-TeX nil t :help "Process file with xelatexmk")))
  ;; (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
#+END_SRC
*** Scheme
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t
  :hook ((geiser-repl-mode . subword-mode)
         (geiser-repl-mode . company-mode)
         (geiser-repl-mode . smartparens-strict-mode)
         (geiser-repl-mode . rainbow-delimiters-mode)
         (geiser-repl-mode . highlight-parentheses-mode)
         (geiser-mode . smartparens-strict-mode)
         (geiser-mode . rainbow-delimiters-mode)
         (geiser-mode . highlight-parentheses-mode))
  :config (setq geiser-mode-start-repl-p t
                geiser-active-implementations '(guile racket)))
#+END_SRC
*** R
#+begin_src emacs-lisp
(use-package ess
  :ensure t)
#+end_src
*** CSS
*** CSV
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t
  :config
  (setq csv-separators '("," ";" "|" " " )))
#+END_SRC

*** Plantuml
#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode ("\\.plantuml\\'" . plantuml-mode)
  :config
  (let ((plantuml-directory (concat user-emacs-directory "private/"))
        (plantuml-link "http://sourceforge.net/projects/plantuml/files/plantuml.jar/download"))
    (let ((plantuml-target (concat plantuml-directory "plantuml.jar")))
      (if (not (file-exists-p plantuml-target))
          (progn (message "Downloading plantuml.jar")
                 (shell-command
                  (mapconcat 'identity (list "wget" plantuml-link "-O" plantuml-target) " "))
                 (kill-buffer "*Shell Command Output*")))
      (setq org-plantuml-jar-path plantuml-target
            plantuml-jar-path plantuml-target
            plantuml-output-type "svg"))))

(use-package flycheck-plantuml
  :config (flycheck-plantuml-setup))

#+END_SRC
*** Go
#+BEGIN_SRC emacs-lisp
  (defvar jong-go-debug-buffer "*jong-go-debug*" "Jong go language debug buffer.")

  (use-package go-mode
    :init (add-hook 'go-mode-hook
                    (lambda ()
                      ;;(setq gofmt-command "goimports")
                      (add-hook 'before-save-hook 'lsp-organize-imports nil t)
                      (setq truncate-lines t)
                      (setq indent-tabs-mode t)
                      (setq tab-width 4)))
    :config
    (progn
      (add-to-list 'auto-mode-alist (cons "\\.go\\'" 'go-mode))))


  (use-package go-guru
          :ensure t)

  (use-package company-go
          :ensure t)

  (use-package go-eldoc
          :ensure t
          :config
          (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package go-complete
          :ensure t
          :config
          (add-hook 'completion-at-point 'go-complete-at-point))

  (defun my-go-mode-hook ()
    ;; prefer goimports, if present
    (if (executable-find "goimports")
        (setq gofmt-command "goimports"))

    ;; Format code when we save
    (add-hook 'before-save-hook 'gofmt-before-save)

    ;; esc-space to jump to definition
    (local-set-key (kbd "M-SPC") 'godef-jump)
    ;; escp-b to jump (b)ack
    (local-set-key (kbd "M-b") 'pop-tag-mark))

  (add-hook 'go-mode-hook 'my-go-mode-hook)

  (use-package go-dlv
          :ensure t)

  (use-package gotest
          :ensure t)

  (defun jong-set-go-envs()
          "Set environment variables relative with go."
          (interactive)
          (when (memq window-system '(mac ns x))
                  (exec-path-from-shell-copy-envs '("PATH" "GOROOT" "GOPATH")))
          )

  (add-to-list 'exec-path (expand-file-name (format "%s/bin" (getenv "GOPATH"))))

  (defun jong-go-chan-gud-stepout ()
          "This is ..."
          (interactive)
          (let ((current-buffer-name (buffer-name))
                                  (gud-buffer-pattern "^\*gud-.*")
                                  (target-buffer nil)
                                  (temp-buffer-list (buffer-list)))
                  ;; Current buffer is gud.
                  (if (and (string-match gud-buffer-pattern current-buffer-name)
                                                   (equal major-mode 'jong-gogud-mode))
                                  (setq target-buffer (current-buffer))
                          (catch 'loop
                                  (dolist (buffer temp-buffer-list)
                                          (with-current-buffer buffer
                                                  (when (and (string-match gud-buffer-pattern (buffer-name buffer))
                                                                                           (equal major-mode 'jong-gogud-mode))
                                                          (setq target-buffer buffer)
                                                          (message "im here!!!")
                                                          (throw 'loop buffer))))))

                  (when target-buffer
                          (with-current-buffer target-buffer
                                  (goto-char (point-max))
                                  (send-string (get-buffer-process (current-buffer)) "stepout\n")))
                  ))


  (defun jong-go-set-gud-shortcut ()
          "Set shortcuts of gud for golang."

          (local-set-key (kbd "<f7>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-print)
                                                                                                                                  (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f8>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-cont)))

          (local-set-key (kbd "<f9>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-break)))

          (local-set-key (kbd "<f10>") (lambda () (interactive)
                                                                                                                                   (call-interactively 'gud-next)
                                                                                                                                   (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f11>") (lambda () (interactive)
                                                                                                                                   (call-interactively 'gud-step)
                                                                                                                                   (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f12>") 'jong-go-chan-gud-stepout))


  (defun jong-get-imported-packages ()
          "Get Imported package "
          (interactive)
          (let ((output-buffer "*jong-output-buffer*")
                                  (extract-pattern-whole "^[[:space:]]*import[[:space:]]*(\\([[:ascii:]]+?\\))")
                                  (extract-pattern-elem "^[[:space:]]*\\([[:alpha:]]+\\)[[:space:]]*\\([\\\s_\\\s-\\\s\"\\\s.\\\s/[[:alpha:]]*]*\\)")
                                  (imported-string "")
                                  (base-pos (point))
                                  (package-url-list nil)
                                  (import-start-pattern "^.*import.*[(]")
                                  (import-end-pattern ".*)")
                                  (extension (file-name-extension (buffer-file-name)))
                                  (buffer-temp nil)
                                  (command nil)
                                  (imported-packages))
                  (unless (equal extension "go")
                          (error "This file is not for golang"))

                  (string-match extract-pattern-whole (buffer-substring-no-properties (point-min) (point-max)))
                  (setq imported-string (match-string 1 (buffer-substring-no-properties (point-min) (point-max))))
                  (setq imported-packages (split-string imported-string "\n"))
                  (with-current-buffer (get-buffer-create output-buffer)
                          (progn
                                  (dolist (package-uri imported-packages)
                                          (if (string-match extract-pattern-elem package-uri)
                                                          (progn
                                                                  (when (match-string 1 package-uri)
                                                                          (insert (format "%s\n" (match-string 1 package-uri)))
                                                                          (start-process-shell-command "go"
                                                                                                                                                                                           (current-buffer)
                                                                                                                                                                                           (format "go get %s" (match-string 1 package-uri))))
                                                                  (when (match-string 2 package-uri)
                                                                          (insert (format "%s\n" (match-string 2 package-uri)))
                                                                          (start-process-shell-command "go"
                                                                                                                                                                                           (current-buffer)
                                                                                                                                                                                           (format "go get %s" (match-string 2 package-uri)))))
                                                  (start-process-shell-command "go"
                                                                                                                                                                   (current-buffer)
                                                                                                                                                                   (format "go get %s" package-uri)))
                                          )
                                  )
                          )
                  )
          )


  (defun jong-set-go-bins ()
          "Check if GOPATH environment variable is set or not.
  And the environment variable was existing, Download go binaries from the internet..."
          (interactive)
          (let ((cmd nil)
                                  (buffer-name "*jong-set-go-bins*")
                                  (list-url (list "github.com/golang/lint/golint"
                                                                                                  "github.com/mdempsky/gocode"
                                                                                                  "github.com/k0kubun/pp"
                                                                                                  "github.com/golang/lint/golint"
                                                                                                  "github.com/rogpeppe/godef"
                                                                                                  "github.com/dougm/goflymake"
                                                                                                  "golang.org/x/tools/cmd/vet"
                                                                                                  "golang.org/x/tools/cmd/godoc"
                                                                                                  "golang.org/x/tools/cmd/guru"
                                                                                                  "golang.org/x/tools/cmd/goimports"
                                                                                                  "golang.org/x/tools/gopls@latest"
                                                                                                  "github.com/go-delve/delve/cmd/dlv")))
                  (if (getenv "GOPATH")
                                  (progn
                                          (dolist (elt list-url cmd)
                                                  (setq cmd (format "go get -u %s" elt))
                                                  (with-current-buffer (get-buffer-create buffer-name)
                                                          (shell-command cmd (current-buffer) (current-buffer)))))
                          (message "There was not the GOPATH environment variable."))
                  )
          )


  (setq gofmt-command "goimports")

  (add-hook 'go-mode-hook 'go-eldoc-setup)
  (add-hook 'go-mode-hook (lambda ()
                                                                                                          (setq gofmt-command "goimports")
                                                                                                          (if (not (string-match "go" compile-command))
                                                                                                                          (set (make-local-variable 'compile-command)
                                                                                                                                           "go build -v && go test -v && go vet"))))

  (defun jong-go-debug-project ()
          "Debug the go project with delve."
          (interactive)
          (let ((cmd nil)
                                  (homedir nil))
                  (setq homedir (projectile-project-root))
                  (if homedir
                                  (with-temp-buffer
                                          (cd homedir)
                                          (call-interactively 'dlv))
                          (message "Couldn't found the projectile root directory."))
                  ))

  (defcustom jong-go-run-command nil
          "This is varialbe for project run."
          :type 'string)

  (defcustom jong-go-run-default-path nil
          "This is varialbe for project default directory."
          :type 'string)

  (defun jong-go-set-project-run-command ()
          (interactive)
          (let ((command))
                  (setq command (read-string "Enter the command : "))
                  (setq jong-go-run-command command)
                  (setq jong-go-run-default-path default-directory)
                  (message "Next run command : [%s], default path : [%s]"
                                                   jong-go-run-command jong-go-run-default-path)
                  )
          )

  (defun jong-go-run-project ()
          (interactive )
          (let ((output-buffer-name "*jong-output*")
                                  (output-buffer nil)
                                  (program-name nil)
                                  (program-args nil))
                  (ignore-errors (kill-buffer output-buffer-name))
                  (with-current-buffer (get-buffer-create output-buffer-name)
                          (if jong-go-run-command
                                          (progn
                                                  (display-buffer (current-buffer))
                                                  (setq default-directory jong-go-run-default-path)
                                                  (async-shell-command jong-go-run-command (current-buffer) (current-buffer)))
                                  (start-process jong-go-run-command (current-buffer) program-name program-args))
                          (message "The command was not setted.")))
          )

  (defun jong-go-run-project-otherframe ()
          (interactive)
          (let ((current-frame (selected-frame))
                                  (output-buffer-name "*jong-output*")
                                  (output-frame-name "log-frame")
                                  (output-buffer nil)
                                  (output-frame nil)
                                  (program-name nil)
                                  (program-args nil))

                  (ignore-errors (kill-buffer output-buffer-name))
                  (setq output-buffer (get-buffer-create output-buffer-name))
                  (if (setq output-frame

                                                          (catch 'found
                                                                  (dolist (frame (frame-list))
                                                                          (if (equal output-frame-name (frame-parameter frame 'name))
                                                                                          (throw 'found frame)))))
                                  (progn
                                          (select-frame-set-input-focus output-frame)
                                          (switch-to-buffer output-buffer-name))
                          (progn
                                  (setq output-frame (make-frame
                                                                                                                  '((name . "log-frame"))
                                                                                                                  ))
                                  (select-frame-set-input-focus output-frame)
                                  (switch-to-buffer output-buffer-name)))
                  (with-current-buffer (get-buffer output-buffer)
                          (if jong-go-run-command
                                          (progn
                                                  (setq default-directory jong-go-run-default-path)
                                                  (async-shell-command jong-go-run-command (current-buffer) (current-buffer)))
                                  (message "go-run-command was not setted...")))
                  (select-frame-set-input-focus current-frame)
                  )
          )


  (define-derived-mode jong-gogud-mode gud-mode "jong-gogud"
          (setq font-lock-defaults '(go--build-font-lock-keywords)))


  (defun chan-gogud-exec-function (target-func)
          "..."
          (interactive)
          (let ((base-line 0)
                                  (target-line 0)
                                  (current-line-buffer "")
                                  (target-symbol "")
                                  (target-offset 0))

                  ;; Initailize other buffer cursor position...
                  (gud-refresh)

                  ;; Get Initial variables...
                  (setq target-line (line-number-at-pos))
                  (setq target-symbol (thing-at-point 'symbol))
                  (if (equal target-symbol nil)
                                  (progn
                                          (message "Target symbol was nil...")
                                          (return)))

                  ;; Get current line buffer...
                  (setq current-line-buffer (buffer-substring-no-properties
                                                                                                                           (line-beginning-position)
                                                                                                                           (line-end-position)))

                  ;; Calculates what times symbol was shown from the line...
                  (setq target-offset
                                          (- (- (- (point) (line-beginning-position))
                                                                  (string-match ":" current-line-buffer)) 2))


                  ;; Get base-line from the gud buffer.
                  (goto-char (point-max))
                  (while (not (string-prefix-p "=>" (current-line-contents)))
                          (forward-line -1)
                          (if (equal (point) 0)
                                          (progn
                                                  (message "Couldnt find the '=>' prefix...")
                                                  (return))))

                  (setq base-line (line-number-at-pos))

                  ;; Move other window and move the point to the target symbol.
                  (other-window 1)
                  (forward-line (- target-line base-line))
                  (line-beginning-position)
                  (goto-char (+ (point) target-offset))
                  (call-interactively target-func)
                  (other-window 1)
                  (with-no-warnings
                          (goto-line target-line))
                  )
          )


  (defun jong-gogud-gdb (&optional cmd)
          "This is delve wrapper based on 'gud-gdb mode."
          (interactive)
          (let ((cmd))
                  (with-current-buffer (current-buffer)
                          (setq cmd (read-string "dlv command :" "dlv exec"))
                          (when (equal cmd nil)
                                  (setq cmd "dlv debug"))
                          (dlv cmd)
                          (jong-gogud-mode)
                          ))
          )


  (defun chan-run-dlv-client(&optional port)
          "Connect the dlv server!!!."
          (interactive)
          (let ((target-port "")
                                  (output-buffer "*gud-connect*")
                                  (process-name nil)
                                  (waiting-seconds 0))

                  (when (get-buffer output-buffer)
                          (with-current-buffer (get-buffer output-buffer)
                                  (while (get-buffer-process (current-buffer))
                                          (comint-send-eof)
                                          (message "waiting killing the gud-connect process. (%d seconds)" waiting-seconds)
                                          (sleep-for 1)
                                          (1+ waiting-seconds))

                                  (kill-buffer (current-buffer))))

                  (if (equal port nil)
                                  (setq target-port (read-string "input listen port : "))
                          (setq target-port port))
                  (dlv (format "dlv connect :%s" target-port))
                  (jong-gogud-mode))
          )


  (defun chan-run-dlv-server()
          "Make run interactively!!!."
          (interactive)
          (let ((target-dir nil)
                                  (output-buffer "*chan-dlv-server*")
                                  (process-name nil)
                                  (listen-process nil))

                  (if (get-buffer output-buffer)
                                  (kill-buffer output-buffer))

                  (if (equal (projectile-project-root) nil)
                                  (setq target-dir (projectile-project-root))
                          (setq target-dir default-directory))

                  ;; start headless delve
                  (with-current-buffer (get-buffer-create output-buffer)
                          (when (get-buffer-process (current-buffer))
                                  (interrupt-process process-name)
                                  (while (get-buffer-process (current-buffer))
                                          (message "Killing process : %s " process-name)
                                          (sleep-for 1))
                                  (comint-clear-buffer))

                          (display-buffer output-buffer)
                          (setq default-directory target-dir)
                          (ignore-errors (term-mode))
                          (start-process "dlv-server-debug" (current-buffer) "dlv" "debug" "--headless")
                          (ignore-errors (term-mode)))
                  )
          )


  (defun chan-run-dlv-cs (&optional otherframe)
          "Create dlv with server and client mode."
          (interactive)
          (let ((port)
                                  (start-pos)
                                  (end-pos)
                                  (magic-seconds 20)
                                  (main-file "main.go")
                                  (log-frame "log-frame")
                                  (input-frame "input-frame")
                                  (target-frame)
                                  (current-frame (selected-frame)))
                  (catch 'exit
                          (condition-case ex
                                          (progn
                                                  ;; Run server dlv process.
                                                  (with-current-buffer (get-buffer main-file)
                                                          (chan-run-dlv-server))
                                                  ;; Waiting a server process reveal.
                                                  (setq port (with-current-buffer (get-buffer "*chan-dlv-server*")
                                                                                                   (while (< (length (buffer-string)) 1)
                                                                                                           (message "waiting the seconds : %d"
                                                                                                                                                  (setq magic-seconds (1- magic-seconds)))
                                                                                                           (sleep-for 1)
                                                                                                           (when (equal magic-seconds 0)
                                                                                                                   (throw 'exit magic-seconds)))
                                                                                                   (goto-char (point-max))
                                                                                                   (forward-line -1)
                                                                                                   (end-of-line)
                                                                                                   (setq end-pos (point))
                                                                                                   (re-search-backward ":")
                                                                                                   (setq start-pos (1+ (point)))
                                                                                                   (buffer-substring start-pos end-pos)))
                                                  ;; Run client dlv process.
                                                  (with-current-buffer (get-buffer main-file)
                                                          (chan-run-dlv-client port)))
                                  (message "There was not a main.go buffer."))
                          (progn
                                  (message "Waiting time was gone...")
                                  nil))

                  (when otherframe
                          (if (setq target-frame
                                                                  (catch 'target
                                                                          (dolist (frame (frame-list))
                                                                                  (if (equal log-frame (frame-parameter frame 'name))
                                                                                                  (throw 'target frame)))))
                                          (progn
                                                  (select-frame-set-input-focus target-frame)
                                                  (switch-to-buffer "*chan-dlv-server*")
                                                  (select-frame-set-input-focus current-frame)
                                                  (switch-to-buffer-other-window main-file)
                                                  (other-window 1)
                                                  )
                                  (progn
                                          (setq target-frame (make-frame
                                                                                                                          '((name . "log-frame"))
                                                                                                                          ))
                                          (select-frame-set-input-focus target-frame)
                                          (switch-to-buffer "*chan-dlv-server*")
                                          (select-frame-set-input-focus current-frame)
                                          (switch-to-buffer-other-window main-file)
                                          (other-window 1)
                                          )))
                  )
          )

  (defun jong-run-dlv-cs-otherframe ()
          "Create dlv with server (other-frame) and client mode."
          (interactive)
          (chan-run-dlv-cs t))


  ;; (add-hook 'go-mode-hook 'jong-go-set-gud-shortcut)
  (add-hook 'go-mode-hook (lambda ()
                                                                                                          (setq lsp-ui-sideline-enable nil)
                                                                                                          (setq lsp-ui-doc-enable nil)
                                                                                                          (setq lsp-gopls-staticcheck t)
                                                                                                          (setq lsp-eldoc-render-all t)
                                                                                                          (setq lsp-gopls-complete-unimported t)
                                                                                                          (lsp)

                                                                                                          (setq indent-tabs-mode t)
                                                                                                          (setq tab-width 4)

                                                                                                          ;; syntax highlight
                                                                                                          (go-guru-hl-identifier-mode)

                                                                                                          ;; setting company-go mode...
                                                                                                          (setq company-tooltip-limit 20)
                                                                                                          (setq company-idle-delay .3)
                                                                                                          (setq company-echo-delay 0)
                                                                                                          (setq company-begin-commands '(self-insert-command))
                                                                                                          (set (make-local-variable 'company-backends) '(company-go))
                                                                                                          (company-mode)

                                                                                                          ;;setting go-eldocp
                                                                                                          (set-face-attribute 'eldoc-highlight-function-argument nil
                                                                                                                                                                                          :underline t :foreground "green"
                                                                                                                                                                                          :weight 'bold)
                                                                                                          (local-set-key (kbd "C-c r w") 'lsp-workspace-restart)
                                                                                                          (local-set-key (kbd "C-c C-r") 'go-remove-unused-imports)
                                                                                                          (local-set-key (kbd "C-c C-a") 'go-import-add)
                                                                                                          (local-set-key (kbd "C-c C-g") 'go-goto-imports)
                                                                                                          (local-set-key (kbd "C-c C-f") 'gofmt)
                                                                                                          (local-set-key (kbd "C-c r .") 'lsp-find-definition)
                                                                                                          (local-set-key (kbd "C-c r ,") 'lsp-find-references)
                                                                                                          (local-set-key (kbd "C-c r i") 'lsp-find-implementation)
                                                                                                          (local-set-key (kbd "C-c r j") 'go-guru-definition)
                                                                                                          (local-set-key (kbd "C-c r d") 'go-guru-describe)
                                                                                                          (local-set-key (kbd "C-c o i") 'lsp-organize-imports)
                                                                                                          (local-set-key (kbd "C-c r l") 'helm-imenu)
                                                                                                          (local-set-key (kbd "C-c g g")
                                                                                                                                                                   (lambda () (interactive)
                                                                                                                                                                           (jong-gogud-gdb "dlv debug")))
                                                                                                          (local-set-key (kbd "C-c g i") 'jong-get-imported-packages)
                                                                                                          (local-set-key (kbd "C-c s f") 'gofmt-before-save)
                                                                                                          (local-set-key (kbd "C-c g c") 'chan-run-dlv-cs)
                                                                                                          (local-set-key (kbd "C-c c c") 'jong-project-compile-project)
                                                                                                          ;; (compile "go build -v && go test -v && go vet")))
                                                                                                          (local-set-key (kbd "C-c r r") 'lsp-rename)
                                                                                                          (local-set-key (kbd "C-c t f") 'go-test-current-test)
                                                                                                          (local-set-key (kbd "C-c t a") 'go-test-current-file)

                                                                                                          ;; (local-set-key (kbd "C-c r r") 'jong-go-run-project-otherframe)
                                                                                                          (local-set-key (kbd "C-c r s") 'jong-go-set-project-run-command)
                                                                                                          (local-set-key (kbd "C-c M->")
                                                                                                                                                                   (lambda () (interactive)
                                                                                                                                                                           (other-window 1)
                                                                                                                                                                           (call-interactively 'end-of-buffer)
                                                                                                                                                                           (other-window -1)))
                                                                                                          )
                                          )


  ;; (add-hook 'chan-gogud-mode-hook 'jong-go-set-gud-shortcut)
  (add-hook 'chan-gogud-mode-hook
                                          (lambda () (local-set-key (kbd "C-c r .")
                                                                                                                                                  (lambda () (interactive)
                                                                                                                                                          (call-interactively 'gud-refresh)
                                                                                                                                                          (chan-gogud-exec-function #'godef-jump)))
                                                  (local-set-key (kbd "C-c r ,")
                                                                                                           (lambda () (interactive)
                                                                                                                   (call-interactively 'gud-refresh)
                                                                                                                   (chan-gogud-exec-function #'go-guru-referrers)))
                                                  (local-set-key (kbd "C-c r i")
                                                                                                           (lambda () (interactive)
                                                                                                                   (call-interactively 'gud-refresh)
                                                                                                                   (chan-gogud-exec-function #'go-guru-implements)))
                                                  ))
#+END_SRC
* Pretty Mode
#+BEGIN_SRC emacs-lisp
(use-package pretty-mode
  :ensure t
  :config
  (add-hook 'clojure-mode-hook #'turn-on-pretty-mode))
#+END_SRC
* GPG
#+BEGIN_SRC emacs-lisp
(setenv "GPG_AGENT_INFO" nil)
(use-package epg
  :requires (epa-file password-cache)
  :config
  (setq epg-gpg-program "/usr/bin/gpg2")
  (setq password-cache-expiry (* 15 60))
  (setq epa-file-cache-passphrase-for-symmetric-encryption t))
#+END_SRC
* Org
** Org General confs
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :hook ((org-mode . toggle-word-wrap)
         (org-mode . org-indent-mode)
         (org-mode . turn-on-visual-line-mode)
         (org-mode . (lambda () (display-line-numbers-mode -1))))
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda))
  :config
  (setq ;org-default-notes-file (concat org-directory "~/sync/orgfiles/notes.org.gpg")
   org-export-html-postamble nil
   org-hide-leading-stars t
   org-startup-indented t
   org-journal-dir "~/sync/orgfiles"
   org-display-inline-images t
   org-redisplay-inline-images t
   org-startup-with-inline-images "inlineimages"
    ;org-agenda-files (list "~/sync/orgfiles/life.org.gpg" "~/sync/orgfiles/personal_cal.org.gpg" "~/sync/orgfiles/work_cal.org.gpg")
   org-todo-keywords '((sequence "TODO(t)" "PENDING(p!)" "WAIT(w@)" "VERIFY(v)" "|" "DONE(d!)" "CANCELED(c@)")
                       (sequence "REPORT(r@)" "BUG(b@)" "KNOWNCAUSE(k@)" "|" "FIXED(f!)"))
   org-edit-src-content-indentation 0
   org-src-tab-acts-natively t
   org-src-fontify-natively t
   org-confirm-babel-evaluate nil
   org-support-shift-select 'always
   org-hide-emphasis-markers        t
   org-edit-src-content-indentation 0
   org-src-tab-acts-natively        t
   org-src-fontify-natively         t
   org-src-preserve-indentation     t)

  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)

  (defun do-org-show-all-inline-images ()
    (interactive)
    (org-display-inline-images t t))
  (global-set-key (kbd "C-c C-x C v")
                  'do-org-show-all-inline-images)

  (use-package ob-restclient)
  (use-package ob-hy)
  (use-package ob-ipython)
  (use-package ob-prolog)
  (use-package ob-async
    :init (setq ob-async-no-async-languages-alist '("ipython")))
  (use-package ox-reveal)
  (org-babel-do-load-languages
   'org-babel-load-languages
   (org-babel-do-load-languages
    'org-babel-load-languages
    (append org-babel-load-languages
            '((emacs-lisp . t)
              (clojure . t)
              (prolog . t)
              (hy . y)
              (python . t)
              (restclient . t)
              (js . t)
              (shell . t)
              (plantuml . t)
              (sql . t)
              (ipython . t)))))
  (setq org-hide-emphasis-markers t
        org-babel-clojure-nrepl-timeout nil
        org-export-allow-bind-keywords t
        org-confirm-babel-evaluate       t)

  (org-defkey org-mode-map "\C-x\C-e" 'cider-eval-last-sexp)
  (org-defkey org-mode-map "\C-c\C-d" 'cider-doc))

    ;; (use-package org-gcal
         ;; :init (load-library "~/.gcal.el.gpg")
         ;; :config (setq org-gcal-file-alist '(("maximoiann@gmail.com" .  "~/sync/orgfiles/personal_cal.org")
                             ;; ("ian@crowd.br.com" . "~/sync/orgfiles/work_cal.org"))))
;; organize journal confs after

(load (expand-file-name (concat user-emacs-directory "sensitive/journal.el")))

(use-package org-journal
  :init
  (defun org-journal-load-files ()
    (interactive)
    (when (not org-journal-loaded)
      (setq org-agenda-file-regexp "\\`[^.].*\\.org'\\|[0-9]$")
      (add-to-list 'org-agenda-files org-journal-dir)
      (setq org-journal-loaded t)))
  :config (setq org-journal-loaded nil))

(setq org-agenda-include-diary t)
#+END_SRC
** Agenda
#+BEGIN_SRC emacs-lisp
(require 'org-agenda)
(setq org-agenda-include-diary t
      calendar-week-start-day 0
      calendar-day-name-array ["Domingo" "Segunda" "Terça" "Quarta"
                               "Quinta" "Sexta" "Sábado"]
      calendar-month-name-array ["Janeiro" "Fevereiro" "Março" "Abril"
                                 "Maio" "Junho" "Julho" "Agosto"
                                 "Setembro" "Outubro" "Novembro" "Dezembro"])

(add-to-list 'org-agenda-custom-commands
             '("Y" "Agenda anual de aniversários e feriados" agenda "Visão Anual"
               ((org-agenda-span 365)
                (org-agenda-filter-by-category 'Aniversário)
                (org-agenda-time-grid nil))))
(add-to-list 'org-agenda-custom-commands
             '("1" "Agenda mensal" agenda "Visão Mensal"
               ((org-agenda-span 31)
                (org-agenda-time-grid nil))))
(add-to-list 'org-agenda-custom-commands
             '("7" "Agenda dos próximos sete dias" agenda "Visão de Sete Dias"
               ((org-agenda-span 7)
                (org-agenda-time-grid nil))))

(load (expand-file-name (concat user-emacs-directory "elisp/brazil-holidays.el")))
(setq calendar-holidays holiday-brazil-all)

(load (expand-file-name (concat user-emacs-directory "sensitive/agenda.el")))
(add-hook 'org-mode-hook 'auto-revert-mode)
#+END_SRC
** Appearance
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :hook ((org-mode . org-bullets-mode))
  :init (setq org-hide-leading-stars t))

(use-package fill-column-indicator
  :config (progn
            (add-hook 'org-mode-hook
                      (lambda ()
                        (setq fci-rule-width 1)
                        (setq fci-rule-color "darkblue")))
            (add-hook 'org-mode-hook 'turn-on-auto-fill)))

#+END_SRC
** Alert
#+BEGIN_SRC emacs-lisp
(use-package org-alert
  :config (progn
            (setq alert-default-style          'libnotify
                  org-alert-notification-title "*org-mode*"
                  org-alert-interval           21600)
            (org-alert-enable)))
#+END_SRC
** Calfw
#+BEGIN_SRC emacs-lisp
(use-package calfw)
(use-package calfw-org
  :requires calfw
  :config )
#+END_SRC
** Org Reveal.js
#+BEGIN_SRC emacs-lisp
(use-package org-re-reveal
  :init (setq org-reveal-mathjax t))

;; (require 'oer-reveal-publish)
;; (oer-reveal-setup-submodules t)
;; (oer-reveal-generate-include-files t)
;; (oer-reveal-publish-setq-defaults)

(use-package org-re-reveal-ref)

(require 'org-ref)
(require 'org-re-reveal-ref)
(setq org-ref-default-bibliography '("references.bib")
      org-ref-bibliography-entry-format
      '(("article" . "%a, %t, <i>%j %v(%n)</i>, %p (%y). <a href=\"%U\">%U</a>")
        ("book" . "%a, %t, %u, %y. <a href=\"%U\">%U</a>")
        ("inproceedings" . "%a, %t, %b, %y. <a href=\"%U\">%U</a>")
        ("incollection" . "%a, %t, %b, %u, %y. <a href=\"%U\">%U</a>")
        ("misc" . "%a, %t, %i, %y.  <a href=\"%U\">%U</a>")
        ("phdthesis" . "%a, %t, %s, %y.  <a href=\"%U\">%U</a>")
        ("techreport" . "%a, %t, %i, %u (%y).")
        ("proceedings" . "%e, %t in %S, %u (%y).")
        ))
#+END_SRC
** Org Crypt
#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key "9CD4DA20")

(setq org-file-apps
      (append '(("\\.pdf\\'" . "evince %s")) org-file-apps))

;;(use-package org-web-tools :ensure t)
#+END_SRC
* Calfw
#+BEGIN_SRC emacs-lisp
(use-package calfw-cal
  :config
  ;; Month
  (progn
    (setq cfw:org-overwrite-default-keybinding t)
    (global-set-key (kbd "<f6>")
                    (lambda ()
                      (interactive)
                      (cfw:open-org-calendar)))
    (setq calendar-month-name-array ["January" "February" "March"     "April"   "May"      "June"
                                    "July"    "August"   "September" "October" "November" "December"]
         calendar-day-name-array ["Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday"]
         calendar-week-start-day 1)
    (custom-set-faces
     '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
     '(cfw:face-header ((t (:foreground "#d0bf8f" :weight bold))))
     '(cfw:face-sunday ((t :foreground "#cc9393" :background "grey10" :weight bold)))
     '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "grey10" :weight bold)))
     '(cfw:face-holiday ((t :background "grey10" :foreground "#8c5353" :weight bold)))
     '(cfw:face-grid ((t :foreground "DarkGrey")))
     '(cfw:face-default-content ((t :foreground "#bfebbf")))
     '(cfw:face-periods ((t :foreground "cyan")))
     '(cfw:face-day-title ((t :background "grey10")))
     '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
     '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
     '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
     '(cfw:face-today-title ((t :background "#7f9f7f" :weight bold)))
     '(cfw:face-today ((t :background: "grey10" :weight bold)))
     '(cfw:face-select ((t :background "#2f2f2f")))
     '(cfw:face-toolbar ((t :foreground "Steelblue4" :background "Steelblue4")))
     '(cfw:face-toolbar-button-off ((t :foreground "Gray10" :weight bold)))
     '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold))))))
(use-package calfw-ical)
(use-package calfw-org)


(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")  ; orgmode source
    ;(cfw:howm-create-source "Blue")  ; howm source
    (cfw:cal-create-source "Orange") ; diary source
    ;(cfw:ical-create-source "Moon" "~/moon.ics" "Gray")  ; ICS source1
    ;(cfw:ical-create-source "gcal" "https://..../basic.ics" "IndianRed") ; google calendar ICS
   )))
#+END_SRC
* Dashboard
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook)
  (progn
    (setq initial-buffer-choice (lambda ()
                                  (get-buffer "*dashboard*"))
          dashboard-center-content t
          dashboard-startup-banner 'logo
          dashboard-set-navigator t
          dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5)
                            (registers . 5)))))
#+END_SRC
* Tramp
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
    :ensure t
    :bind
      ("s-e" . sudo-edit))

(use-package counsel-tramp
  :config (setq tramp-default-method "ssh"))
#+END_SRC
* Iedit and narrow/widen dwin
#+BEGIN_SRC emacs-lisp
; mark and edit all copies of the marked region simultaniously.
(use-package iedit
  :ensure t)

; if you're windened, narrow to the region, if you're narrowed, widen
; bound to C-x n
(defun narrow-or-widen-dwim (p)
"If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, org-src-block, org-subtree, or defun,
whichever applies first.
Narrowing to org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is already
narrowed."
(interactive "P")
(declare (interactive-only))
(cond ((and (buffer-narrowed-p)
            (not p))
       (widen))
      ((region-active-p)
       (narrow-to-region (region-beginning) (region-end)))
      ((derived-mode-p 'org-mode)
       ;; `org-edit-src-code' is not a real narrowing command.
       ;; Remove this first conditional if you don't want it.
       (cond ((ignore-errors (org-edit-src-code))
              (delete-other-windows))
             ((org-at-block-p)
              (org-narrow-to-block))
             (t (org-narrow-to-subtree))))
      (t (narrow-to-defun))))
#+END_SRC
* Try
- Try is a package that allows you to try out Emacs packages without installing them. If you pass a URL to a plain text .el-file it evaluates the content, without storing the file.
#+BEGIN_SRC emacs-lisp
(use-package try
    :ensure t)
#+END_SRC

* Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
         :config
         (which-key-mode))
#+END_SRC
* COMMENT Evil
#+BEGIN_SRC emacs-lisp
  ;; (use-package evil
    ;; :ensure t
    ;; :init
    ;; (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
    ;; (setq evil-want-keybinding nil)
    ;; :config
    ;; (evil-mode 1)

  ;; (use-package evil-collection
    ;; :after evil
    ;; :ensure t
    ;; :config
    ;; (evil-collection-init)
#+END_SRC
* Better Shell
#+BEGIN_SRC emacs-lisp
(use-package better-shell
  :ensure t
  :bind (("C-\"" . better-shell-shell)
         ("C-:" . better-shell-remote-open)))

(use-package shell
  :ensure nil
  :commands comint-send-string comint-simple-send comint-strip-ctrl-m
  :preface
  (defun n-shell-simple-send (proc command)
    "Various PROC COMMANDs pre-processing before sending to shell."
    (cond
     ;; Checking for clear command and execute it.
     ((string-match "^[ \t]*clear[ \t]*$" command)
      (comint-send-string proc "\n")
      (erase-buffer))
     ;; Checking for man command and execute it.
     ((string-match "^[ \t]*man[ \t]*" command)
      (comint-send-string proc "\n")
      (setq command (replace-regexp-in-string "^[ \t]*man[ \t]*" "" command))
      (setq command (replace-regexp-in-string "[ \t]+$" "" command))
      ;;(message (format "command %s command" command))
      (funcall 'man command))
     ;; Send other commands to the default handler.
     (t (comint-simple-send proc command))))
  (defun n-shell-mode-hook ()
    "Shell mode customizations."
    (local-set-key '[up] 'comint-previous-input)
    (local-set-key '[down] 'comint-next-input)
    (local-set-key '[(shift tab)] 'comint-next-matching-input-from-input)
    (setq comint-input-sender 'n-shell-simple-send))
  :hook ((shell-mode . ansi-color-for-comint-mode-on)
         (shell-mode . n-shell-mode-hook))
  :config
  (setq system-uses-terminfo nil)       ; don't use system term info

  (add-hook 'comint-output-filter-functions #'comint-strip-ctrl-m)

  ;; Company mode backend for shell functions
  (use-package company-shell
    :after company
    :init (cl-pushnew '(company-shell company-shell-env company-fish-shell)
                      company-backends))

  ;; Bash completion
  (use-package bash-completion
    :init (bash-completion-setup))

  ;; ANSI & XTERM 256 color support
  (use-package xterm-color
    :defines compilation-environment
    :init
    (setenv "TERM" "xterm-256color")
    (setq comint-output-filter-functions
          (remove 'ansi-color-process-output comint-output-filter-functions))

    (add-hook 'shell-mode-hook
              (lambda () (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))))

#+END_SRC
* Keyfreq
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :config
  (require 'keyfreq)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
* Personal Keymap
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ian Fernandez"
      user-mail-address "ianffcs@tutanota.com")
(global-set-key (kbd "<menu>")
          (lambda () (interactive) (find-file "~/.emacs.d/init.org")))
#+END_SRC
* Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :bind ("C-x g" . magit-status)
  :init
  (setq magit-diff-options (quote ("--word-diff"))
        magit-diff-refine-hunk 'all)
  :config
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))

(use-package magit-gitflow)

(use-package git-gutter
  :ensure t
  :init
  (global-git-gutter-mode +1))

;; Use evil keybindings within magit
  ;  (use-package evil-magit
  ;    :ensure t
  ;    :config
  ;    ;; Default commit editor opening in insert mode
  ;    (add-hook 'with-editor-mode-hook 'evil-insert-state)
  ;    (evil-define-key 'normal with-editor-mode-map
  ;      (kbd "RET") 'with-editor-finish
  ;      [escape] 'with-editor-cancel
  ;      )
  ;    (evil-define-key 'normal git-rebase-mode-map
  ;      "l" 'git-rebase-show-commit))
#+END_SRC
* COMMENT PDF Tools
#+BEGIN_SRC emacs-lisp
(when (not (eq system-type 'darwin))
  (use-package pdf-tools
    :pin manual
    :config
    ;; initialise
    (pdf-tools-install)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)
    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)
    ;; use normal isearch
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
    ;; turn off cua so copy works
    (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
    ;; more fine-grained zooming
    (setq pdf-view-resize-factor 1.1)
    ;; keyboard shortcuts
    (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
    (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
    (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete))

(use-package org-pdfview
  :ensure t))
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile-ripgrep)
(use-package projectile
      :ensure t
      :bind ("C-c p" . projectile-command-map)
      :config
      (projectile-global-mode)
      (setq projectile-completion-system 'ivy))
#+END_SRC
* Regex
#+BEGIN_SRC emacs-lisp
(use-package pcre2el
  :ensure t
  :config (pcre-mode))
#+END_SRC
* Media
** EMMS with mpd
There is many backends, many players and codecs for EMMS, we use mpd now.
*** Basic setup for mpd
The non XF86 keys are made to be somewhat logical to follow and easy to remember.
At the bottom part of the configuration, you will notice how XF86 keys are used
by default, so unless you keyboard is broken it should work out of the box.
Obviously you might have to adjust /server-name/ and /server-port/ to fit your configuration.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :config
      (require 'emms-setup)
      (require 'emms-player-mpd)
      (emms-all) ; don't change this to values you see on stackoverflow questions if you expect emms to work
      (setq emms-seek-seconds 5)
      (setq emms-player-list '(emms-player-mpd))
      (setq emms-info-functions '(emms-info-mpd))
      (setq emms-player-mpd-server-name "localhost")
      (setq emms-player-mpd-server-port "6601")
    :bind
      ("s-m p" . emms)
      ("s-m b" . emms-smart-browse)
      ("s-m r" . emms-player-mpd-update-all-reset-cache)
      ("<XF86AudioPrev>" . emms-previous)
      ("<XF86AudioNext>" . emms-next)
      ("<XF86AudioPlay>" . emms-pause)
      ("<XF86AudioStop>" . emms-stop))
#+END_SRC

*** MPC Setup
**** Setting the default port
We use non-default settings for the socket, to use the built in =mpc= functionality we need to set up a variable.
Adjust according to your setup.
#+BEGIN_SRC emacs-lisp
  (setq mpc-host "localhost:6601")
#+END_SRC

*** Some more fun stuff
**** Starting the daemon from within emacs
If you have an absolutely massive music library, it might be a good idea to get rid of =mpc-update=
and only invoke it manually when needed.
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connects to it and syncs the metadata cache."
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD Started!"))
  (global-set-key (kbd "s-m c") 'mpd/start-music-daemon)
#+END_SRC

**** Killing the daemon from within emacs
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stops playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed!"))
  (global-set-key (kbd "s-m k") 'mpd/kill-music-daemon)
#+END_SRC
**** Updating the database easily.
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated!"))
  (global-set-key (kbd "s-m u") 'mpd/update-database)
#+END_SRC
* COMMENT Slack
#+BEGIN_SRC emacs-lisp
(use-package slack
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify t) ;; if you want to enable emoji, default nil
  (setq slack-prefer-current-team t)
  :config
  (slack-register-team
   :name "PayGo"
   :default t
   :client-id ""
   :client-secret ""
   :token ""))

(use-package alert
  :commands (alert)
  :init
  (setq alert-default-style 'notifier))
#+END_SRC
* COMMENT ORG Jira
#+BEGIN_SRC emacs-lisp
(defconst org-jira-progress-issue-flow
  '(("To Do" . "Start Progress")
    ("In Development" . "Ready For Review")
    ("Code Review" . "Done")
    ("Done" . "Reopen")))

(use-package org-jira
  :config
  (setq jiralib-url "https://paygo.atlassian.net/")
  (define-key org-jira-map (kbd "C-c pg") 'org-jira-get-projects)
  (define-key org-jira-map (kbd "C-c ib") 'org-jira-browse-issue)
  (define-key org-jira-map (kbd "C-c ig") 'org-jira-get-issues)
  (define-key org-jira-map (kbd "C-c ij") 'org-jira-get-issues-from-custom-jql)
  (define-key org-jira-map (kbd "C-c ih") 'org-jira-get-issues-headonly)
  (define-key org-jira-map (kbd "C-c iu") 'org-jira-update-issue)
  (define-key org-jira-map (kbd "C-c iw") 'org-jira-progress-issue)
  (define-key org-jira-map (kbd "C-c in") 'org-jira-progress-issue-next)
  (define-key org-jira-map (kbd "C-c ia") 'org-jira-assign-issue)
  (define-key org-jira-map (kbd "C-c ir") 'org-jira-refresh-issue)
  (define-key org-jira-map (kbd "C-c iR") 'org-jira-refresh-issues-in-buffer)
  (define-key org-jira-map (kbd "C-c ic") 'org-jira-create-issue)
  (define-key org-jira-map (kbd "C-c ik") 'org-jira-copy-current-issue-key)
  (define-key org-jira-map (kbd "C-c sc") 'org-jira-create-subtask)
  (define-key org-jira-map (kbd "C-c sg") 'org-jira-get-subtasks)
  (define-key org-jira-map (kbd "C-c cc") 'org-jira-add-comment)
  (define-key org-jira-map (kbd "C-c cu") 'org-jira-update-comment)
  (define-key org-jira-map (kbd "C-c wu") 'org-jira-update-worklogs-from-org-clocks)
  (define-key org-jira-map (kbd "C-c tj") 'org-jira-todo-to-jira)
  (define-key org-jira-map (kbd "C-c if") 'org-jira-get-issues-by-fixversion))
#+END_SRC
* Telega
#+BEGIN_SRC emacs-lisp
(use-package telega
  :load-path  "~/telega.el"
  :commands (telega)
  :defer t)
#+END_SRC
* COMMENT Wakatime
#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :ensure t
  :config
  (setq wakatime-api-key ""))
#+END_SRC
