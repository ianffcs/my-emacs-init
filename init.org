#+TITLE: Ian Emacs config
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+STARTUP: overview inlineimages
* Meta
#+BEGIN_SRC emacs-lisp
;;;; Initialization
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
           (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
       ;   (byte-compile-file (concat user-emacs-directory "init.el"))
      )))

   (add-hook 'after-save-hook 'tangle-init)
#+END_SRC
* Personal Keymap
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ian Fernandez"
      user-mail-address "ianffcs@tutanota.com")
(global-set-key (kbd "<menu>")
          (lambda () (interactive) (find-file "~/.emacs.d/init.org")))

(defalias 'cquit 'cider-quit)
(defalias 'yes-or-no-p 'y-or-n-p)
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
* Beginning
#+BEGIN_SRC emacs-lisp
;(eval-when-compile
; (setq use-package-expand-minimally byte-compile-current-file))
;; ;;-----------------


(defvar current-user
  (getenv
   (if (equal system-type 'windows-nt) "USERNAME" "USER")))

(message "Let the coding begin! Be patient, %s!" current-user)

;; Always load newest byte code
(setq load-prefer-newer t)
#+END_SRC
* Performance adjustments

Adjust GC cons threshold, which is low by default.
Garbage collection shouldn't happen during startup, as what will
slow Emacs down. Do it later.
Ease the font caching during GC.
Enforce a sneaky GC strategy to minimize GC interference with the
activity. During normal use a high GC threshold is set, when
idling GC is immediately triggered and a low threshold is set.
#+begin_src emacs-lisp
  (setq gc-cons-threshold 100000000)

  ;; (use-package gcmh
  ;;   :ensure t
  ;;   :delight gcmh-mode
  ;;   :init
  ;;   (setq gcmh-verbose t)
  ;;   :config
  ;;   (gcmh-mode 1))

  (setq inhibit-compacting-font-caches t)
#+end_src

Increase amount of data which Emacs reads from the process.

(Changed to a defvar instead of =setq= because Emacs complained. Is this
deprecated?)

#+begin_src emacs-lisp
(defvar read-process-output-max (* 1024 2048)) ; 1 megabyte
#+end_src

* Repos
#+BEGIN_SRC emacs-lisp
  ;;;; Packaging
  (setq package-enable-at-startup nil)
  (setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
               ("marmalade" . "https://marmalade-repo.org/packages/")
               ;;("melpa-stable" . "https://stable.melpa.org/packages/")
               ("tromey" . "http://tromey.com/elpa/")
               ("melpa" . "https://melpa.org/packages/")
               ("org" . "https://orgmode.org/elpa/")))

  (package-initialize)

  ;;;; use-package
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))

  (setq use-package-always-ensure t)

;; auto-package-update
(use-package auto-package-update
  :config
  (auto-package-update-maybe)
  (setq auto-package-update-delete-old-versions t))
#+END_SRC
* Custom
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name (concat user-emacs-directory "custom/custom.el")))
(load custom-file)
#+END_SRC
* Async
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :defer t
  :init
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1)
  :custom (async-bytecomp-allowed-packages '(all)))
#+END_SRC
* Mac custom keyboard
#+BEGIN_SRC emacs-lisp
  (defun paste-from-osx ()
    (shell-command-to-string "pbpaste"))

  (defun copy-to-osx (text &optional push)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
    (process-send-string proc text)
    (process-send-eof proc))))

  ;; Check the system
  (when (eq system-type 'darwin)
    (setq ;interprogram-cut-function 'copy-to-osx
            ;interprogram-paste-function 'paste-from-osx
            mac-emulate-three-button-mouse nil
            mac-option-modifier 'command
            mac-command-modifier 'meta
            mac-right-command-modifier 'meta
            mac-right-option-modifier 'control
            ;mac-option-key-is-control t
  ))
#+END_SRC
* Clipboard
Allow pasting selection outside of Emacs
#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t)
#+END_SRC

Say you copied a link from your web browser, then switched to Emacs
to paste it somewhere. Before you do that, you notice something you
want to kill. Doing that will place the last kill to the clipboard,
thus overriding the thing you copied earlier. We can have a kill ring solution:
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
* Linux specific settings
** Exec-path from shell
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
 :config
 (when (eq system-type 'gnu/linux)
  (exec-path-from-shell-initialize)))
#+END_SRC
** Exec-path updates
#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (setenv "NODE_VERSION"									 ;;
;;         (concat "/home/ianffcs/.nvm/versions/node/"						 ;;
;;                 (substring (shell-command-to-string "/usr/bin/node --version") 0 -1) "/bin")) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (setq exec-path                  ;;
;;       (nconc exec-path (getenv "NODE_VERSION"))) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(setq exec-path
      (append exec-path '("/home/ianffcs/.nvm/versions/node/v12.11.1/bin")))
#+END_SRC
* Interface Visual
** UTF-8
#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(set-terminal-coding-system  'utf-8)   ; pretty
(set-keyboard-coding-system  'utf-8)   ; pretty
(set-selection-coding-system 'utf-8)   ; please
(prefer-coding-system        'utf-8)   ; with sugar on top
(setq default-process-coding-system '(utf-8-unix . utf-8-unix)
      locale-coding-system          'utf-8)
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
(when window-system
  (use-package pretty-mode
      :config
      (global-pretty-mode t))
  (global-prettify-symbols-mode))

;; (defconst my-default-font "-*-fixed-medium-r-normal-*-15-*-*-*-*-*-*-*")
;; (defconst my-default-font "-misc-fixed-*-*-*-*-12-*-*-*-*-*-*-*")
;; (defconst my-default-font "-b&h-lucidatypewriter-medium-r-normal-sans-14-*-*-*-*-*-iso8859-1")
;; (defconst my-default-font "FantasqueSansMono Nerd Font-10")
;; (defconst my-default-font "Monoid-9")
;; (defconst my-default-font "Fixed-10")
;;(defconst my-default-font "Dina-10")
;; (defconst my-default-font "Iosevka-9")
;; (defconst my-default-font "Terminus-10")
(defconst my-default-font "Fira Code-10")
;; (defconst my-default-font "Hack-10")


(defun fira-code-mode--make-alist (list)
  "Generate prettify-symbols alist from LIST."
  (let ((idx -1))
    (mapcar
     (lambda (s)
       (setq idx (1+ idx))
       (let* ((code (+ #Xe100 idx))
          (width (string-width s))
          (prefix ())
          (suffix '(?\s (Br . Br)))
          (n 1))
     (while (< n width)
       (setq prefix (append prefix '(?\s (Br . Bl))))
       (setq n (1+ n)))
     (cons s (append prefix suffix (list (decode-char 'ucs code))))))
     list)))

(defconst fira-code-mode--ligatures
  '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
    "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
    "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
    "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
    ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
    "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
    "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
    "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
    ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
    "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
    "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
    "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
    "x" ":" "+" "+" "*"))

(defvar fira-code-mode--old-prettify-alist)

(defun fira-code-mode--enable ()
  "Enable Fira Code ligatures in current buffer."
  (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
  (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
  (prettify-symbols-mode t))

(defun fira-code-mode--disable ()
  "Disable Fira Code ligatures in current buffer."
  (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
  (prettify-symbols-mode -1))

(define-minor-mode fira-code-mode
  "Fira Code ligatures minor mode"
  :lighter " Fira Code"
  (setq-local prettify-symbols-unprettify-at-point 'right-edge)
  (if fira-code-mode
      (fira-code-mode--enable)
    (fira-code-mode--disable)))

(defun fira-code-mode--setup ()
  "Setup Fira Code Symbols"
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))
#+END_SRC
** Visual
Find out what face something at point have.

#+BEGIN_SRC emacs-lisp
(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property (point) 'read-face-name)
                  (get-char-property (point) 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defconst my-frame-alist
  `((font                 . ,my-default-font)
    (scroll-bar           . -1)
    (height               . 60)
    (width                . 95)
    (alpha                . 95)
    (vertical-scroll-bars . nil)))

(setq default-frame-alist my-frame-alist)

(use-package all-the-icons
     :ensure t)
#+END_SRC

** Themes
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :init (setq doom-themes-enable-bold t doom-themes-enable-italic t)
  :config
  (doom-themes-org-config))

(use-package zenburn-theme
  :defer t)

(use-package solarized-theme
  :defer t)

(use-package organic-green-theme
  :defer t)
#+END_SRC
*** Default theme
#+BEGIN_SRC emacs-lisp
;(load-theme 'doom-one t)
(add-hook 'after-init-hook
                (lambda () (interactive)
                  ;(setq organic-green-boldless t)
                  ;(load-theme 'doom-monokai-pro t)
                  (load-theme 'doom-vibrant t)
                  ;(load-theme 'zenburn t)
                  ;(load-theme 'organic-green t)
))
#+END_SRC

** Cleaning
Since I never use the mouse with GNU Emacs, I prefer not to use
invasive graphical elements.
#+BEGIN_SRC emacs-lisp
(when window-system
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1))
#+END_SRC

Emacs convention is to show help and other inline documentation in
the message area. Show help there instead of OS tooltip.

#+BEGIN_SRC emacs-lisp
(when
  (display-graphic-p)
  (tooltip-mode -1))
#+END_SRC

Let's remove some crunchy messages at startup time.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen        t
      inhibit-splash-screen t
      inhibit-startup-echo-area-message t)

;; where put this?
(setq line-number-mode              1
      column-number-mode            1
      show-paren-mode               1
      show-paren-delay              0
      blink-cursor-mode             nil
      transient-mark-mode           1
      scroll-bar-mode               -1
      browser-url-browse-function   'browse-url-firefox
      linum-format                  "%5d"
      tab-width                     4
      global-hl-line-mode           t
      indent-tabs-mode              nil
      truncate-partial-width-windows 1
      fill-column                   80
      truncate-lines                1
      save-interprogram-paste-before-kill t)
#+END_SRC

** Which-key mode
[[https://github.com/justbur/emacs-which-key][Describing keystrokes]]
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC
** Emacs Cursor
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :config (progn
            (add-hook 'org-mode-hook
                      (lambda ()
                        (setq fci-rule-width 1)
                        (setq fci-rule-color "darkblue")))
            (add-hook 'org-mode-hook 'turn-on-auto-fill)))

(set-cursor-color "#ffffff")
#+END_SRC

[[https://github.com/Malabarba/beacon][Beacon, never lose your cursor]]
#+BEGIN_SRC emacs-lisp
(use-package beacon
    :ensure t
    :config
    (beacon-mode 1))
#+END_SRC

Change the highlight color for selection text.
#+BEGIN_SRC emacs-lisp
      (set-face-attribute 'region nil :background "#666")
#+END_SRC

Make cursor the width of the character it is under.
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

** Mouse Scrolling
Smooth mouse scrolling
#+BEGIN_SRC emacs-lisp
(setq transentient-mark-mode        t
      mouse-wheel-follow-mouse      t
      scroll-step                   1
      scroll-conservatively         101
      mouse-wheel-scroll-amount     '(1)
      mouse-wheel-progressive-speed nil)

(use-package smooth-scrolling
  :config (smooth-scrolling-mode 1))
#+END_SRC
** Frame
#+BEGIN_SRC emacs-lisp
(defun custom-set-frame-size ()
  (add-to-list 'default-frame-alist '(height . 50))
  (add-to-list 'default-frame-alist '(width . 178)))
(custom-set-frame-size)
(add-hook 'before-make-frame-hook 'custom-set-frame-size)

(defun set-frame-alpha (value)
  "Set the transparency of the frame. 0 = transparent/100 = opaque"
  (interactive "Alpha value (0-100): ")
  (set-frame-parameter (selected-frame) 'alpha value))

(set-frame-alpha 90)
#+END_SRC
** Time
#+BEGIN_SRC emacs-lisp
(use-package time
  :ensure nil
  :init
  (setq display-time-default-load-average nil
        display-time-format "%Hh%M "
        display-time-day-and-date t)
  :config
  (display-time-mode t))
   #+END_SRC
** Fringe

    Control the fringe around the frame.
    #+BEGIN_SRC emacs-lisp
      (fringe-mode '(10 . 1))
    #+END_SRC

    Preview line numbers when prompting for line number.
    #+BEGIN_SRC emacs-lisp
      (define-advice goto-line (:before (&rest _) preview-line-number)
        "Preview line number when prompting for goto-line."
        (interactive
         (lambda (spec)
           (if (and (boundp 'display-line-numbers)
                    (not display-line-numbers))
               (unwind-protect
                   (progn (display-line-numbers-mode)
                          (advice-eval-interactive-spec spec))
                 (display-line-numbers-mode -1))
             (advice-eval-interactive-spec spec)))))
    #+END_SRC
** Extra-stuff
#+BEGIN_SRC emacs-lisp
(use-package mode-icons
  :config (mode-icons-mode))

;; happy cat
(use-package nyan-mode
  :ensure t
  :init
  (setq nyan-animate-nyancat t
    nyan-wavy-trail t
    mode-line-format
    (list '(:eval (list (nyan-create)))))
  (nyan-mode t))

;; party yey!
(use-package parrot
  :config
  (global-set-key (kbd "C-c p") 'parrot-rotate-prev-word-at-point)
  (global-set-key (kbd "C-c n") 'parrot-rotate-next-word-at-point)
  (parrot-set-parrot-type 'science)
  (parrot-mode)
  (add-hook 'before-save-hook 'parrot-start-animation))

;; emojis! =)
(use-package emojify
  :hook ((after-init-hook . global-emojify-mode)))

;; HIGHLIGHT WHEN ;; TODO
(use-package hl-todo
  :config
  (global-hl-todo-mode 1))

; Show current key-sequence in minibuffer, like vim does. Any feedback
;  after typing is better UX than no feedback at all
(setq echo-keystrokes 0.2)

#+END_SRC
* Persistent-scratch
#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC
* Backup
#+BEGIN_SRC emacs-lisp
(setq backup-by-copying 1      ; don't clobber symlinks
      ;; store all backup and autosave files in the tmp dir
      backup-directory-alist  `((".*" . ,temporary-file-directory))
      auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
                                        ; use versioned backups
      delete-old-versions 1
      kept-new-versions 6
      kept-old-versions 2
      version-control 1)

(use-package savehist
  :config
  (setq savehist-additional-variables
        ;; search entries
        '(search-ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-mode +1))
#+END_SRC
* Proced (htop builtin)
#+BEGIN_SRC emacs-lisp
(setq proced-auto-update-flag t
      proced-auto-update-interval 1
      proced-descend t)
#+END_SRC
* Completion Framework Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :diminish (ivy-mode)
  :bind (("C-x b" . ivy-switch-buffer)
         ("C-c C-r" . ivy-resume))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "%d/%d ")
  (setq ivy-display-style 'fancy))

(use-package swiper
  :bind (("C-s" . swiper-isearch))
  :config
  (ivy-mode 1))

(use-package anzu
  :config
  (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))

(use-package counsel
  :bind
  (("M-x" . counsel-M-x)
   ("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line))
  :config
  (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file))
#+END_SRC
** Ivy-rich

It is also interesting to use =ivy-rich= for a... richer... Ivy
experience.

#+begin_src emacs-lisp
;; Function for buffer icons
(defun ivy-rich-switch-buffer-icon (candidate)
  (with-current-buffer
      (get-buffer candidate)
    (let ((icon (all-the-icons-icon-for-mode major-mode)))
      (if (symbolp icon)
          (all-the-icons-icon-for-mode 'fundamental-mode)
        icon))))

(use-package ivy-rich
  :config (progn
            (ivy-rich-mode 1)
            (setcdr (assq t ivy-format-functions-alist)
                    #'ivy-format-function-line)
            (setq ivy-rich-display-transformers-list
                  '(ivy-switch-buffer
                    (:columns
                     (;; Buffer icon
                      (ivy-rich-switch-buffer-icon (:width 2))
                      ;; return the candidate itself
                      (ivy-rich-candidate (:width 30))
                      ;; return the buffer size
                      ;;(ivy-rich-switch-buffer-size (:width 7))
                      ;; return the buffer indicators
                      (ivy-rich-switch-buffer-indicators
                       (:width 4 :face error :align right))
                      ;; return the major mode info
                      (ivy-rich-switch-buffer-major-mode
                       (:width 12 :face warning))
                      ;; return project name using `projectile'
                      ;; (ivy-rich-switch-buffer-project
                      ;;  (:width 15 :face success))
                      ;; return file path relative to project root
                      ;; or `default-directory' if project is nil
                      (ivy-rich-switch-buffer-path
                       (:width (lambda (x)
                                 (ivy-rich-switch-buffer-shorten-path
                                  x
                                  (ivy-rich-minibuffer-width 0.3))))))
                     :predicate
                     (lambda (cand) (get-buffer cand)))
                    counsel-M-x
                    ;; (:columns
                    ;;  ;; the original transformer
                    ;;  ((counsel-M-x-transformer (:width 40))
                    ;;   (ivy-rich-counsel-function-docstring
                    ;;    ;; return the docstring of the command
                    ;;    (:face font-lock-doc-face))))
                    ;; Two-column mode
                    (:columns
                     ((counsel-M-x-transformer (:width 40))
                      (ivy-rich-counsel-function-docstring
                       (:face font-lock-doc-face))))
                    counsel-describe-function
                    (:columns
                     ;; the original transformer
                     ((counsel-describe-function-transformer (:width 40))
                      ;; return the docstring of the function
                      (ivy-rich-counsel-function-docstring
                       (:face font-lock-doc-face))))
                    counsel-describe-variable
                    (:columns
                     ;; the original transformer
                     ((counsel-describe-variable-transformer (:width 40))
                      (ivy-rich-counsel-variable-docstring
                       ;; return the docstring of the variable
                       (:face font-lock-doc-face))))
                    counsel-recentf
                    (:columns
                     ;; return the candidate itself
                     ((ivy-rich-candidate (:width 0.8))
                      (ivy-rich-file-last-modified-time
                       ;; return the last modified time of the file
                       (:face font-lock-comment-face))))))))
#+end_src
** Ivy-posframe

Floaty stuff is floaty. But floaty stuff can only be floaty when EXWM
is not being used.

#+begin_src emacs-lisp
(use-package ivy-posframe
  :config (progn
            (setq ivy-posframe-display-functions-alist
                  '((t . ivy-posframe-display-at-frame-center))
                  ivy-posframe-parameters
                  '((left-fringe   . 8)
                    (right-fringe  . 8)))
            (ivy-posframe-mode 1)))
#+end_src

** COMMENT Ivy-Bibtex

This tool is very useful for managing Bibtex entries, including notes
and associated PDF files.

Associated file =sensitive/helm-bibtex.el= defines the variable
=bibtex-completion-bibliography=, which is a list of paths to actual
Bibtex files for bibliography. It also defines
=bibtex-completion-library-path=.

#+begin_src emacs-lisp
(use-package ivy-bibtex
  ;;:config (progn (load-sensible-file "helm-bibtex.el")
    ;;             (setq bibtex-completion-pdf-field "File"))
)
#+end_src

** Ivy-YouTube

This queries YouTube stuff from Emacs and plays it on the browser.

#+begin_src emacs-lisp
(use-package ivy-youtube)
#+end_src
* Editor confs
#+BEGIN_SRC emacs-lisp

(setq ring-bell-function 'ignore)

(setq-default indent-tabs-mode nil  ;; don't use tabs to indent
              tab-width 4         ;; but maintain correct appearance
              fill-column 80)

;; revert buffers automatically when underlying files are changed externally
(global-auto-revert-mode t)

;; Newline at end of file
(setq require-final-newline t)

;; Word wrapping
(setq-default word-wrap t
              truncate-lines t
              truncate-partial-width-windows nil
              sentence-end-double-space nil
              delete-trailing-lines nil
              require-final-newline t
              tabify-regexp "^\t* [ \t]+")

;; Favor hard-wrapping in text modes
;; (defun auto-fill ()
;;   "My autofill setup for text buffers."
;;   (auto-fill-mode t)
;;   (delight 'auto-fill-mode))

;; (add-hook 'text-mode-hook #'auto-fill)

(setq shift-select-mode nil)

;; clean up obsolete buffers automatically
(use-package midnight)

(defmacro with-region-or-buffer (func)
  "When called with no active region, call FUNC on current buffer."
  `(defadvice ,func (before with-region-or-buffer activate compile)
     (interactive
      (if mark-active
          (list (region-beginning) (region-end))
        (list (point-min) (point-max))))))

(with-region-or-buffer indent-region)
(with-region-or-buffer untabify)
#+END_SRC
** Recentf

   This is a built-in mode that keeps track of the files you have
   opened allowing you go back to them faster. It can also integrate
   with a completion framework to populate a =virtual buffers= list.

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :ensure nil
       :init
       (setq recentf-max-saved-items 50
             recentf-max-menu-items 15
             recentf-show-file-shortcuts-flag nil
             recentf-auto-cleanup 'never)
       :config
       (recentf-mode t))
   #+END_SRC
** Uniquify

   Uniquify buffer names dependent on file name. Emacs's traditional
   method for making buffer names unique adds <2>, <3>, etc to the end
   of (all but one of) the buffers. This settings change the default
   behavior.

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :ensure nil
       :config
       (setq uniquify-buffer-name-style 'post-forward-angle-brackets
             uniquify-separator " * "
             uniquify-after-kill-buffer-p t
             uniquify-strip-common-suffix t
             uniquify-ignore-buffers-re "^\\*"))
   #+END_SRC
** Registers

Emacs registers are compartments where you can save text, rectangles,
positions, and other things for later use. Once you save text or a
rectangle in a register, you can copy it into the buffer once or many
times; once you save a position in a register, you can jump back to
that position once or many times.

For more information: `C-h r' and then letter *i* to search for
registers and the amazing video from [[https://youtu.be/u1YoF4ycLTY][Protesilaos]].

The prefix to all commands of registers is *C-x r*


| command             | description                         |
|---------------------+-------------------------------------|
| M-x view-register R | see what register R contains        |
| C-x r s             | save region to register             |
| C-x r i             | insert text from a register         |
| C-x r n             | record a number defaults to 0       |
| C-x r +             | increment a number from register    |
| C-x r SPC           | record a position into register     |
| C-x r j             | jump to positions or windows config |
| C-x r w             | save a window configuration         |
| C-x r f             | save a frame configuration          |


Important note: the data saved into the register is persistent as long
as you don't override it.

The way to specify a number, is to use an universal argument e.g.
*C-u <number> C-x n*


Clean all the registers you saved.
#+BEGIN_SRC emacs-lisp
  (defun bk/clear-registers ()
    "Remove all saved registers."
    (interactive)
    (setq register-alist nil))
#+END_SRC


#+begin_src emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/README.org"))
  (set-register ?t '(file . "~/org/todo.org"))
  (set-register ?c '(file . "~/.emacs.d/docs/cheatsheet.org"))

#+end_src
** Abbreviation

#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :delight abbrev-mode
    :config
    (setq-default abbrev-mode t))

  (defun bk/add-region-local-abbrev (start end)
    "Go from START to END and add the selected text to a local abbrev."
    (interactive "r")
    (if (use-region-p)
        (let ((num-words (count-words-region start end)))
          (add-mode-abbrev num-words)
          (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a l") 'bk/add-region-local-abbrev)

  (defun bk/add-region-global-abbrev (start end)
    "Go from START to END and add the selected text to global abbrev."
    (interactive "r")
    (if (use-region-p)
        (let ((num-words (count-words-region start end)))
          (add-abbrev global-abbrev-table "Global" num-words)
          (deactivate-mark))
      (message "No selected region!")))

  (global-set-key (kbd "C-x a g") 'bk/add-region-global-abbrev)
#+end_src
** Imenu

   The objectives of this package is to provide a way to choose buffer
   indexes in a specific mode. What is a buffer index? Basically we
   have a function that will find "interesting" positions in your
   buffer that you might want to jump there, something like function
   definitions, headlines in outline mode, class definitions, etc.

   #+BEGIN_SRC emacs-lisp
     (use-package imenu-anywhere
       :ensure t
       :bind
       ("C-." . imenu-anywhere))
   #+END_SRC
** IBuffer

   | ibuffer-expert    | Stop asking for confirmation after every action in Ibuffer |
   | ibuffer-auto-mode | Keeps the buffer list up to date

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
       :ensure nil
       :init
       (setq ibuffer-expert t)
       (setq ibuffer-show-empty-filter-groups nil)
       (setq ibuffer-saved-filter-groups
             '(("Main"
                ("Directories" (mode . dired-mode))
                ("Rest" (mode . restclient-mode))
                ("Docker" (or
                           (mode . docker-compose-mode)
                           (mode . dockerfile-mode)))
                ("Programming" (or
                                (mode . clojure-mode)
                                (mode . emacs-lisp-mode)
                                (mode . python-mode)))
                ("Browser" (or
                            (name . "qutebrowser:\*")
                            (name . "Firefox:\*")
                            ))
                ("Slack" (name . "*Slack"))
                ("Org" (mode . org-mode))
                ("Markdown" (or
                             (mode . markdown-mode)
                             (mode . gfm-mode)))
                ("Git" (or
                        (mode . magit-blame-mode)
                        (mode . magit-cherry-mode)
                        (mode . magit-diff-mode)
                        (mode . magit-log-mode)
                        (mode . magit-process-mode)
                        (mode . magit-status-mode)))
                ("Emacs" (or
                          (name . "^\\*Help\\*$")
                          (name . "^\\*Custom.*")
                          (name . "^\\*Org Agenda\\*$")
                          (name . "^\\*info\\*$")
                          (name . "^\\*scratch\\*$")
                          (name . "^\\*Backtrace\\*$")
                          (name . "^\\*Messages\\*$"))))))
       :config
       (add-hook 'ibuffer-mode-hook
                 (lambda ()
                   (ibuffer-auto-mode 1)
                   (ibuffer-switch-to-saved-filter-groups "Main"))))

;; Package =ibuffer-vc= let you filter the Ibuffer by projects
;; definitions (in my case, every folder that has a =.git= folder
;; inside is considered a project).


(use-package ibuffer-vc
       :ensure t
       :after ibuffer
       :config
       (define-key ibuffer-mode-map (kbd "/ V") 'ibuffer-vc-set-filter-groups-by-vc-root))

;;  Increasing the width of each column in ibuffer. Some buffers names
;;  are very large in EXWM.


(setq ibuffer-formats
      '((mark modified read-only " "
              (name 60 60 :left :elide) ; change: 60s were originally 18s
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " " filename-and-process)
             (mark " "
                   (name 16 -1)
                   " " filename)))


(use-package ibuffer-tramp)

(use-package ibuffer-projectile)

(use-package ibuffer-git)

(use-package ibuffer-sidebar
  :commands (ibuffer-sidebar-toggle-sidebar)
  :config
  (setq ibuffer-sidebar-use-custom-font t)
  (setq ibuffer-sidebar-face `(:family "Helvetica" :height 140)))
#+END_SRC
** Autocompletion

Let's set up autocompletions.

#+begin_src emacs-lisp
(setq tab-always-indent 'complete)
(add-to-list 'completion-styles 'initials t)
#+end_src
* COMMENT Authentication Source / Security

   Auth Source is a generic interface for common backends such as your
   operating sysetm's keychain and your local ~/.authinfo file. Auth
   Source solves the problem of mapping passwords and usernames to hosts.

   Debugging auth issues
   #+BEGIN_SRC emacs-lisp
     (setq auth-source-debug t)
   #+END_SRC

   We need to tell auth-source where to look for secrets.
   #+BEGIN_SRC emacs-lisp
     (setq auth-sources '((:source "~/.emacs.d/secrets/.authinfo")))
   #+END_SRC

   GPG

   #+BEGIN_SRC emacs-lisp
(use-package pinentry :ensure t)
(use-package epa
    :config
    (setq epa-pinentry-mode 'loopback)
    (pinentry-start))

(setenv "GPG_AGENT_INFO" nil)
(use-package epg
  :requires (epa-file password-cache)
  :config
  (setq epg-gpg-program "/usr/bin/gpg2")
  (setq password-cache-expiry (* 15 60))
  (setq epa-file-cache-passphrase-for-symmetric-encryption t))
   #+END_SRC
* Help
Is good to know how to ask for help in Emacs
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)
   ("C-h ," . helpful-at-point)))
#+END_SRC
* Text editing stuff?
** Paragraph
See also =bidi-paragraph-direction=; setting that non-nil might speed up
redisplay.

#+BEGIN_SRC emacs-lisp
(setq bidi-paragraph-direction 'left-to-right)
#+END_SRC
** Very large files
Since I am using EXWM, I might open very large files, there is a
package to help Emacs handle this kind of files.

#+BEGIN_SRC emacs-lisp
(use-package vlf
  :defer t)
 #+END_SRC
I found a good paper about =log files= in Emacs where they mention
=vlf= package. This
[[https://writequit.org/articles/working-with-logs-in-emacs.html][paper]]
is very worth reading nevertheless.
** move through edit points

Emacs leaves a trail of breadcrumbs (the mark ring) through which
we can navigate to hop around to places you've been in the buffer.
A nice alternative is to move round through points at which you
made edits in a buffer.
#+BEGIN_SRC emacs-lisp
(use-package goto-chg
  :ensure t
  :config
  (global-set-key (kbd "C-c b ,") 'goto-last-change)
  (global-set-key (kbd "C-c b .") 'goto-last-change-reverse))
#+END_SRC

Now we can use =C-c b ,= and =C-c b .= to go back and forth
through the edit points in your buffer. It takes you through your
undo history without undoing anything.
** Highlights

   Visual feedback on some operations like yank, kill, undo. An
   example is that if you paste the next key. This is just a small
   tweak, but gives a nice bit of visual feedback.

   #+BEGIN_SRC emacs-lisp
     (use-package volatile-highlights
       :ensure t
       :delight volatile-highlights-mode
       :defer t
       :config
       (volatile-highlights-mode t))
   #+END_SRC

   Very often is useful to highlight some symbols.
   #+BEGIN_SRC emacs-lisp
     (use-package highlight-symbol
       :ensure t
       :delight highlight-symbol-mode
       :hook
       ((highlight-symbol-mode . highlight-symbol-nav-mode)
        (prog-mode . highlight-symbol-mode))
       :custom
       (highlight-symbol-highlight-single-occurrence nil)
       (highlight-symbol-idle-delay 0.25)
       (highlight-symbol-on-navigation-p t))
   #+END_SRC
** Multiple Cursors
[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] is a very nice package that lets you create
several cursors that all do the same thing as you type.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind
  (("C->" . mc/mark-next-like-this)
   ("C-<" . mc/mark-previous-like-this)
   ("C-S-<mouse-1>" . mc/add-cursor-on-click)
   ("C-c m c" . mc/edit-lines)))
#+end_src

   To use =mc/edit-lines= you need to highlight the lines on which you
   wish to have cursors and use =C-c m c=. Now you can edit away and
   press enter when you are done to exit multiple cursors.

   There is this amazing [[http://emacsrocks.com/e13.html][video]] from magnars showing off multiple
   cursors features.

   However, occasionally the best way to get the cursors where you
   want them is with the mouse. With the following code, =C-S-<left
   mouse click>= adds a new cursor.
** Smart move to beginning of visible line (or not)

    Very nice default.

    #+begin_src emacs-lisp
      ;; `C-a' first takes you to the first non-whitespace char as
      ;; `back-to-indentation' on a line, and if pressed again takes you to
      ;; the actual beginning of the line.
      (defun smarter-move-beginning-of-line (arg)
        "Move depending on ARG to beginning of visible line or not.
        From https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/."
        (interactive "^p")
        (setq arg (or arg 1))
        (when (/= arg 1)
          (let ((line-move-visual nil))
        (forward-line (1- arg))))
        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
        (move-beginning-of-line 1))))

      (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
    #+end_src
** Duplicate line or region

    #+BEGIN_SRC emacs-lisp
      (defun duplicate-current-line-or-region (arg)
        "Duplicates the current line or region ARG times.
      If there's no region, the current line will be duplicated."
        (interactive "p")
        (save-excursion
          (if (region-active-p)
              (duplicate-region arg)
            (duplicate-current-line arg))))

      (defun duplicate-region (num &optional start end)
        "Duplicates the region bounded by START and END NUM times.
      If no START and END is provided, the current region-beginning
      region-end is used."
        (interactive "p")
        (let* ((start (or start (region-beginning)))
               (end (or end (region-end)))
               (region (buffer-substring start end)))
          (goto-char start)
          (dotimes (i num)
            (insert region))))

      (defun duplicate-current-line (num)
        "Duplicate the current line NUM times."
        (interactive "p")
        (when (eq (point-at-eol) (point-max))
          (goto-char (point-max))
          (newline)
          (forward-char -1))
        (duplicate-region num (point-at-bol) (1+ (point-at-eol))))
    #+END_SRC

    Let's bind the top level function to a sensible key.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c 2") 'duplicate-current-line-or-region)
    #+END_SRC
** Extra functions
#+BEGIN_SRC emacs-lisp

; deletes all the whitespace when you hit backspace or delete
(use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))

;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
    ;; This would override `fill-column' if it's an integer.
    (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
   logical line.  This is useful, e.g., for use with `visual-line-mode'."
  (interactive "*r")
  (let ((fill-column (point-max)))
    (fill-region beg end)))

;; before save clears whitespace
(add-hook 'before-save-hook 'whitespace-cleanup)


(global-set-key (kbd "<f5>") 'revert-buffer)

(global-set-key (kbd "C-c i") 'string-inflection-all-cycle)
#+END_SRC
** Flyspell
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :config
  (setq flyspell-mode +1)
  (setq ispell-program-name "aspell" ; use aspell instead of ispell
        ispell-extra-args '("--sug-mode=ultra")))
#+END_SRC
* COMMENT Modeline
** Telephone-line

(Unfortunately, Org Journal doesn't work fine with it... I still need
to mitigate the problem, but I'll just disable it for now)

#+begin_src emacs-lisp
  (use-package telephone-line
    :config (progn
              (setq telephone-line-primary-left-separator    'telephone-line-cubed-left
                    telephone-line-secondary-left-separator  'telephone-line-cubed-hollow-left
                    telephone-line-primary-right-separator   'telephone-line-cubed-right
                    telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right
                    telephone-line-height                    24
                    telephone-line-evil-use-short-tag        t))
    (telephone-line-mode 1))
#+end_src

*** COMMENT Mini-modeline

Simplistic and small modeline for my needs, specially on EXWM.

#+begin_src emacs-lisp
(use-package mini-modeline
  :config (mini-modeline-mode t))
#+end_src
* Dired
#+BEGIN_SRC emacs-lisp
;; dired - reuse current buffer by pressing 'a'
(put 'dired-find-alternate-file 'disabled nil)

;; always delete and copy recursively
(setq dired-recursive-deletes 'always)
(setq dired-recursive-copies 'always)

;; if there is a dired buffer displayed in the next window, use its
;; current subdir, instead of the current subdir of this dired buffer
(setq dired-dwim-target t)

(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :ensure t
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
            (lambda ()
              (unless (file-remote-p default-directory)
                (auto-revert-mode))))
  :config
  (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
  (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

  (setq dired-sidebar-subtree-line-prefix "__"
        dired-sidebar-use-term-integration t
        dired-sidebar-use-custom-font t)
  ;(setq dired-sidebar-theme 'vscode)
  )

(defun sidebar-toggle ()
  "Toggle both `dired-sidebar' and `ibuffer-sidebar'."
  (interactive)
  (dired-sidebar-toggle-sidebar)
  (ibuffer-sidebar-toggle-sidebar))

(global-set-key (kbd "C-x <menu>") 'sidebar-toggle)
#+END_SRC
** Functions

Some custom functions for Dired.
#+begin_src emacs-lisp
(require 'dired-x)

(defun bk/dired-xdg-open ()
  "Open the file at point with xdg-open."
  (interactive)
  (let ((file (dired-get-filename nil t)))
    (message "Opening %s..." file)
    (call-process "xdg-open" nil 0 nil file)
    (message "Opening %s done" file)))

(eval-after-load 'dired
  '(define-key dired-mode-map (kbd "O") 'bk/dired-xdg-open))
 #+end_src

#+BEGIN_SRC emacs-lisp
(defun bk/dired-directories-first ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2)
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(advice-add 'dired-readin :after #'bk/dired-directories-first)
#+END_SRC

M-up is nicer in dired if it moves to the third line - straight to
the "..", which M-down is nicer if it moves to the last file and
finally C-a moving back to start of files.

#+BEGIN_SRC emacs-lisp
(defun dired-back-to-top ()
  (interactive)
  (beginning-of-buffer)
  (next-line 2)
  (dired-back-to-start-of-files))

(defun dired-back-to-bottom ()
  (interactive)
  (end-of-buffer)
  (next-line -1)
  (dired-back-to-start-of-files))

(defun dired-back-to-start-of-files ()
  (interactive)
  (backward-char (- (current-column) 2)))
 #+END_SRC

Let's bind the functions defined above so it can take effect in
dired.
#+BEGIN_SRC emacs-lisp
(eval-after-load 'dired
  '(progn
     (define-key dired-mode-map (kbd "M-p") 'dired-back-to-top)
     (define-key dired-mode-map (kbd "M-n") 'dired-back-to-bottom)
     (define-key dired-mode-map (kbd "C-a") 'dired-back-to-start-of-files)))
#+END_SRC

* Eshell
 #+begin_src emacs-lisp
      (use-package eshell-bookmark
        :ensure t
        :config
        (add-hook 'eshell-mode-hook 'eshell-bookmark-setup))

      (setenv "PAGER" "cat")

      (defun eshell-clear-buffer ()
        "Clear the terminal buffer."
        (interactive)
        (let ((inhibit-read-only t))
          (erase-buffer)
          (eshell-send-input)))

      (add-hook 'eshell-mode-hook (lambda ()
                                (local-set-key (kbd "C-l") 'eshell-clear-buffer)))

    #+end_src
 #+begin_src emacs-lisp
(require 'em-alias)
(add-hook 'eshell-mode-hook
          (lambda ()
            (eshell/alias "e" "find-file $1")
            (eshell/alias "ee" "find-file-other-window $1")))
#+end_src
 This is very useful if you want to keep some default windows around
 while you edit in your main programming environment. For example,
 to keep a eshell and dired buffer around.
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :custom
  (display-buffer-alist
   '(("\\*e?shell\\*"
      (display-buffer-in-side-window)
      (window-height . 0.30)
      (side . bottom)
      (slot . -1))))
  :bind
  ("<f8>" . window-toggle-side-windows))
 #+END_SRC
* Smartparens & Parens-thing
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :diminish
  :init
  (define-key smartparens-mode-map (kbd "M-(") 'sp-wrap-round)
  (define-key smartparens-mode-map (kbd "M-[") 'sp-wrap-square)
  (define-key smartparens-mode-map (kbd "M-{") 'sp-wrap-curly)
  (define-key smartparens-mode-map (kbd "C-c (") 'sp-unwrap-sexp)
  :config
  (require 'smartparens-config)
  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (sp-use-paredit-bindings)
  (show-smartparens-global-mode +1)
  (sp-local-pair '(emacs-lisp-mode) "'" "'" :actions nil)
  (sp-local-pair '(common-lisp-mode) "'" "'" :actions nil)
  (sp-local-pair '(clojure-mode) "'" "'" :actions nil)
  (sp-local-pair '(cider-repl-mode) "'" "'" :actions nil)
  (sp-local-pair '(scheme-mode) "'" "'" :actions nil)
  (sp-local-pair '(lisp-mode) "'" "'" :actions nil)
  (setq smartparens-global-strict-mode 1))

(use-package highlight-parentheses)

(use-package highlight-sexp)

  #+END_SRC
* Movin' around baby
** split-switch
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))

  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)

(use-package windmove
  :config
  (windmove-default-keybindings))

;; avy allows us to effectively navigate to visible things
(use-package avy
  :bind ("M-s a" . avy-goto-char)
  :config
  (setq avy-background t
          avy-style 'at-full))

(use-package ace-window
        :ensure t
        :init
        (setq aw-keys '(?h ?j ?k ?l ?y ?u ?i ?o ?p)
          aw-background nil
          aw-scope 'frame
          aw-dispatch-alist
          '((?s aw-swap-window "swap window")
            (?2 aw-split-window-vert "split window vertically")
            (?3 aw-split-window-horz "split window horizontally")
            (?? aw-show-dispatch-help)))
        :config
        (ace-window-display-mode -1)
        (global-set-key (kbd "C-x o") 'ace-window))

;; Don't popup certain buffers

(add-to-list 'display-buffer-alist
             (cons "\\*Async Shell Command\\*.*"
                   (cons #'display-buffer-no-window nil)))
#+END_SRC

** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!
#+BEGIN_SRC emacs-lisp
  (use-package mark-multiple
    :ensure t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC
** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/kill-inner-word ()
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC

** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
  (defun daedreth/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
        (point-at-bol)
        (point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'daedreth/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC
** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC
** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
A lot more useful than you might think. If you wish to include the selected character in the killed region,
change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
  (use-package zzz-to-char
    :ensure t
    :bind ("M-z" . zzz-up-to-char))
#+END_SRC
** Shackle

   https://www.reddit.com/r/emacs/comments/7au3hj/how_do_you_manage_your_emacs_windows_and_stay_sane/
   https://github.com/Alexander-Miller/dotfiles/blob/master/.config/spacemacs/user-config.org#shackle


   Gives you the means to put an end to popped up buffers not behaving
   the way you'd like them to. By setting up simple rules you can for
   instance make Emacs always select help buffers for you or make
   everything reuse your currently selected window.

   #+BEGIN_SRC emacs-lisp
     (use-package shackle
       :ensure t
       :config
       (setq shackle-rules '(("*Ledger Report*" :same t)))
       (add-hook 'after-init-hook 'shackle-mode))
   #+END_SRC

** Winner

Winner is a built-in tool that keeps a record of buffer and window
layout changes. It then allows us to move back and forth in the
history of said changes. The mnemonic is related to Emacs default
commands to operating on windows (C-x 4) and the undo operations with
[uU] letter.

There are some buffers that winner will not restore, I list them in
the *winner-boring-buffers*.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure nil
    :hook (after-init . winner-mode)
    :init
    (setq winner-dont-bind-my-keys t)
    (setq winner-boring-buffers
          '("*Completions*"
            "*Compile-Log*"
            "*inferior-lisp*"
            "*Fuzzy Completions*"
            "*Apropos*"
            "*Help*"
            "*cvs*"
            "*Buffer List*"
            "*Ibuffer*"
            "*esh command on file*"))
    :bind (("C-x 4 u" . winner-undo)
           ("C-x 4 U" . winner-redo)))
#+END_SRC

* buffers stuff
** Always murder current buffer
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))

(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC
** Kill buffers without asking for confirmation
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-queray-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

** Turn switch-to-buffer into ibuffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("dired" (mode . dired-mode))
               ("org" (name . "^.*org$"))
               ("magit" (mode . magit-mode))
               ("IRC" (or (mode . circe-channel-mode) (mode . circe-server-mode)))
               ("web" (or (mode . web-mode) (mode . js2-mode)))
               ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
               ("mu4e" (or (mode . mu4e-compose-mode)
                           (name . "\*mu4e\*")))
               ("programming" (or (mode . clojure-mode)
                                  (mode . clojurescript-mode)
                                  (mode . python-mode)
                                  (mode . c++-mode)))
               ("emacs" (or (name . "^\\*scratch\\*$")
                            (name . "^\\*Messages\\*$")))))))

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-auto-mode 1)
            (ibuffer-switch-to-saved-filter-groups "default")))

(setq ibuffer-show-empty-filter-groups nil)

;; Don't ask for confirmation to delete marked buffers
(setq ibuffer-expert t)
#+END_SRC
*** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
(setq ibuffer-expert t)
#+END_SRC
** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC
* COMMENT Manage external services

   Very interesting package that help us to have some instances of
   external processes running and keep track of it all. I often need
   to enable the VPN of my company to work remotely, this suits
   nicely.

   #+BEGIN_SRC emacs-lisp
     (use-package prodigy
       :ensure t
       :config
       (prodigy-define-service
         :name "Captalys VPN"
         :command "captalys-vpn"
         :tags '(captalys)
         :stop-signal 'sigkill
         :kill-process-buffer-on-stop t)

       (prodigy-define-service
         :name "Blog"
         :command "lein ring server"
         :cwd "~/bartuka-blog"
         :stop-signal 'sigkill
         :tags '(blog)
         :kill-process-buffer-on-stop t)

       (prodigy-define-tag
         :name 'captalys
         :ready-message "Initialization Sequence Completed")
       (prodigy-define-tag
         :name 'blog
         :ready-message "Started server on port 3000"))
   #+END_SRC
* Restart Emacs
#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC
* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC
* Autocomplete
#+BEGIN_SRC emacs-lisp  :tangle no
(use-package auto-complete
         :ensure t
         :init
         (progn
           (ac-config-default)
           (global-auto-complete-mode t)))
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode t))
#+END_SRC
* Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))

(use-package auto-yasnippet
  :ensure t)

(use-package yasnippet-snippets
  :after (yas-global-mode))
#+END_SRC
* Langs
** General
*** Prog mode
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'common-lisp-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'scheme-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))

(add-hook 'prog-mode-hook 'display-line-numbers-mode)

(setq sp-base-key-bindings 'paredit)
(setq sp-autoskip-closing-pair 'always)
(setq sp-hybrid-kill-entire-symbol nil)
(sp-use-paredit-bindings)

(use-package eldoc
       :ensure nil
       :delight eldoc-mode
       :init
       (setq eldoc-idle-delay 0.1
             eldoc-echo-area-use-multiline-p nil)
       (eldoc-mode 1)
       :config
       (add-hook 'prog-mode-hook 'turn-on-eldoc-mode))

(add-hook 'prog-mode-hook (defun bk--add-watchwords ()
                            (font-lock-add-keywords
                             nil `(("\\<\\(FIX\\(ME\\))?\\|TODO\\)"
                                    1 font-lock-warning-face t)))))
#+END_SRC
**** smart shift
   #+begin_src emacs-lisp
     (use-package smart-shift
       :ensure t
       :config
       (global-smart-shift-mode t))
   #+end_src
**** Hide block of code

Enable hide definitions functions
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :defer t
  :commands (hs-toggle-hiding)
  :delight hs-minor-mode
  :config
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (global-set-key (kbd "C-c h") 'hs-toggle-hiding))
#+END_SRC
**** expand region
#+begin_src emacs-lisp
(use-package expand-region)
#+end_src

*** Lisp General Mode
#+BEGIN_SRC emacs-lisp
(use-package highlight-sexp)
(use-package highlight-numbers
  :config (add-hook 'prog-mode-hook 'highlight-numbers-mode))


(use-package flycheck)
(require 'semantic)

;; (global-semanticdb-minor-mode        1)
;; (global-semantic-idle-scheduler-mode 1)
;; (global-semantic-stickyfunc-mode     0)

;; (semantic-mode 1)

#+END_SRC
Org and Mu4e's compose buffer use =auto-fill-mode=. I like to wrap on
column 80.

#+begin_src emacs-lisp
(setq fill-column 80)
#+END_SRC
*** Highlight Numbers
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :config (add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC
*** Flycheck confs
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config (progn
            (add-hook 'after-init-hook #'global-flycheck-mode)
            ;; Disable JSHint and json-jsonlist
            (setq-default flycheck-disabled-checkers
                          (append flycheck-disabled-checkers
                                  '(javascript-jshint
                                    json-jsonlist)))))
#+END_SRC
*** Semantic confs
#+BEGIN_SRC emacs-lisp
(require 'semantic)

(global-semanticdb-minor-mode        1)
(global-semantic-idle-scheduler-mode 1)
(global-semantic-stickyfunc-mode     0)

(semantic-mode 1)
#+END_SRC
*** Company confs
Company is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to retrieve and display completion candidates.
#+BEGIN_SRC emacs-lisp
(use-package company
  :delight company-mode
  :init
  (setq company-show-numbers t
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case t
        company-tooltip-limit 10
        company-minimum-prefix-length 2
        company-require-match 'never
        company-tooltip-align-annotations t
        company-transformers '(company-sort-by-occurrence)
        company-idle-delay 0.5)
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 3)
  (global-company-mode t))

(use-package company-irony
  :ensure t
  :config
  (add-to-list 'company-backends 'company-irony))

(use-package irony
  :ensure t
  :config
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))

(use-package irony-eldoc
  :ensure t
  :config
  (add-hook 'irony-mode-hook #'irony-eldoc))

  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
  ;; (use-package company-jedi
  ;;   :ensure t
  ;;   :config
  ;;   (add-hook 'python-mode-hook 'jedi:setup))

  ;; (defun my/python-mode-hook ()
  ;;   (add-to-list 'company-backends 'company-jedi))

  ;; (add-hook 'python-mode-hook 'my/python-mode-hook)
#+END_SRC
Also, we numbered all the candidates and the following code will
enable us to choose the candidate based on its number. This solution
was stolen from [[https://oremacs.com/2017/12/27/company-numbers/][link]] with some customization and simplification to
provide only what I saw useful.
#+begin_src emacs-lisp
(defun ora-company-number ()
  "Choose the candidate based on his number at candidate list."
  (interactive)
  (let* ((k (this-command-keys))
         (re (concat "^" company-prefix k)))
    (if (cl-find-if (lambda (s) (string-match re s)) company-candidates)
        (self-insert-command)
      (company-complete-number (string-to-number k)))))

(defun ora-activate-number ()
  "Activate the number-based choices in company."
  (interactive)
  (let ((map company-active-map))
    (mapc
     (lambda (x)
       (define-key map (format "%d" x) 'ora-company-number))
     (number-sequence 0 9))
    ;; (define-key map " " (lambda ()
    ;;                       (interactive)
    ;;                       (company-abort)
    ;;                       (self-insert-command 1)))
    (define-key map (kbd "<return>") nil)))

(eval-after-load 'company
  '(ora-activate-number))
#+end_src
*** Hippie Expand

[[https://www.emacswiki.org/emacs/HippieExpand][Hippie Expand]] is a more feature complete completion engine than the
default dabbrev engine. The main feature I use over =dabbrev= is
that is supports a wide range of backends for finding completions -
=dabbrev= only looks at currently open buffers.

#+BEGIN_SRC emacs-lisp
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
#+END_SRC

Then we override =dabbrev-expand='s keybinding to use
=hippie-expand= instead.
#+BEGIN_SRC emacs-lisp
(define-key (current-global-map) [remap dabbrev-expand] 'hippie-expand)
#+END_SRC
*** Aggressive Indent
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent)
#+END_SRC
*** NVM
#+BEGIN_SRC emacs-lisp
(use-package nvm)
#+END_SRC
*** LSP Mode
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :hook (;;(clojure-mode . lsp)
         (haskell-mode . lsp))
  ;;   :custom
  ;;   ((lsp-clojure-server-command '("java" "-jar" "/home/ianffcs/Downloads/clj-kondo-lsp-server-2020.01.27-standalone.jar")))
  ;;   :config
  ;;   (dolist (m '(clojure-mode
  ;;                clojurescript-mode))
  ;;     (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
  :commands lsp)

(use-package lsp-ui
  :ensure t
  :commands lsp-ui-mode)
#+END_SRC
** By Lang Configuration
*** Agda
#+BEGIN_SRC emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+END_SRC
*** Bash
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
  (add-hook 'shell-mode-hook 'flycheck-mode)
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
*** Clisp
#+BEGIN_src emacs-lisp
(use-package slime
  :hook ((slime-mode . smartparens-strict-mode)
         (slime-mode . rainbow-parens-mode)
         (slime-mode . highlight-parentheses-mode))
  :mode
  ("\\.lisp$" . slime-mode)
  :init
  (setq inferior-lisp-program "/usr/bin/sbcl"
        slime-net-coding-system 'utf-8-unix
        slime1-contribs '(slime-fancy)))

#+END_SRC
*** Elisp
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
(add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
(add-hook 'emacs-lisp-mode-hook #'highlight-parentheses-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-strict-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'rainbow-delimiters-mode)
(add-hook 'eval-expression-minibuffer-setup-hook #'highlight-parentheses-mode)
(add-hook 'ielm-mode-hook             #'smartparens-strict-mode)
(add-hook 'ielm-mode-hook             #'rainbow-delimiters-mode)
(add-hook 'ielm-mode-hook #'highlight-parentheses-mode)
(add-hook 'lisp-mode-hook             #'smartparens-strict-mode)
(add-hook 'lisp-mode-hook             #'rainbow-delimiters-mode)
(add-hook 'lisp-mode-hook #'highlight-parentheses-mode)
(add-hook 'lisp-interaction-mode-hook #'smartparens-strict-mode)
(add-hook 'lisp-interaction-mode-hook #'rainbow-delimiters-mode)
(add-hook 'lisp-interaction-mode-hook #'highlight-parentheses-mode)
(add-hook 'scheme-mode-hook           #'smartparens-strict-mode)
(add-hook 'scheme-mode-hook           #'rainbow-delimiters-mode)
(add-hook 'scheme-mode-hook #'highlight-parentheses-mode)
(add-hook 'emacs-lisp-mode-hook  #'highlight-sexp-mode)
;; eldoc-mode shows documentation in the minibuffer when writing code
;; http://www.emacswiki.org/emacs/ElDoc
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)

(defun ielm-auto-complete ()
  "Enables `auto-complete' support in \\[ielm]."
  (setq ac-sources '(ac-source-functions
                     ac-source-variables
                     ac-source-features
                     ac-source-symbols
                     ac-source-words-in-same-mode-buffers))
  (auto-complete-mode 1))

(defun ielm/clear-repl ()
  "Clear current REPL buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    (ielm-send-input)))
#+END_SRC
*** Clojure
 #+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)

(use-package clojure-mode-extra-font-locking)

(defun prettify-some-chars ()
  (dolist (x '((true        т)
               (false       ғ)
               (:keys       ӄ)
               (:strs       ş)
               (nil           Ø)
               (partial     Ƥ)
               (with-redefs я)
               (defn        ƒ)
               (comp        º)
               (apply       ζ)
               (a-fn1       α)
               (a-fn2       β)
               (a-fn3       γ)
               (no-op       ε)))

    (font-lock-add-keywords
     nil `((,(concat "[\[({[:space:]]"
                               "\\(" (symbol-name (first x)) "\\)"
                               "[\])}[:space:]]")
                      (0 (progn (compose-region (match-beginning 1)
                                                (match-end 1) ,(symbol-name (second x)))
                                nil)))))
    (font-lock-add-keywords
     nil `((,(concat "^"
                     "\\(" (symbol-name (first x)) "\\)"
                     "[\])}[:space:]]")
            (0 (progn (compose-region (match-beginning 1)
                                      (match-end 1) ,(symbol-name (second x)))
                      nil)))))
    (font-lock-add-keywords
     nil `((,(concat "[\[({[:space:]]"
                                "\\(" (symbol-name (first x)) "\\)"
                                "$")
                       (0 (progn (compose-region (match-beginning 1)
                                                 (match-end 1) ,(symbol-name (second x)))
                                 nil)))))
    ;; prettify set
    (font-lock-add-keywords
     nil `(("\\(#\\){"
            (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                      "∈")
                    nil)))))
    ;; prettify fn's
    (font-lock-add-keywords
     nil `(("\\(#\\)("
          (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                    ,(make-char 'greek-iso8859-7 107))
                    nil)))))))

(use-package clojure-mode
  :hook ((clojure-mode . aggressive-indent-mode)
         (clojure-mode . smartparens-strict-mode)
         (clojure-mode . subword-mode)
         (clojure-mode . cider-mode)
         (clojure-mode . clj-refactor-mode)
         (clojure-mode . rainbow-delimiters-mode)
         (clojure-mode . highlight-sexp-mode)
         (clojure-mode . highlight-parentheses-mode)
         (clojure-mode . prettify-some-chars))
  :config
  (progn
    (eval-after-load 'clojure-mode
      '(define-clojure-indent
         (train-n 3)
         (for-all 1)
         (fdef 1)
         (mlet 1)
         (alet 1)
         ;;(async 1)
         (defapi '(2 nil nil (1)))
         (server 2)
         (sniptest 1)
         (reg-event-db 1)
         (reg-sub 1)
         (reg-sub-raw 1)
         (reg-event-fx 1)
         (reg-fx 1)
         (reg-cofx 1)
         (at-media 1)
         (GET 2)
         (not-join 1)
         (recursive-path 2)
         (wcar 1)
         (implement '(1 (1)))
         (letfn     '(1 ((:defn)) nil))
         (proxy     '(2 nil nil (1)))
         (reify     '(:defn (1)))
         (deftype   '(2 nil nil (1)))
         (defrecord '(2 nil nil (1)))
         (specify   '(1 (1)))))
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (hack-local-variables)
    (setq clojure-align-forms-automatically 1)))

(use-package clojurescript-mode
  :hook ((clojurescript-mode . aggressive-indent-mode)
         (clojurescript-mode . smartparens-strict-mode)
         (clojurescript-mode . subword-mode)
         (clojurescript-mode . cider-mode)
         (clojurescript-mode . clj-refactor-mode)
         (clojurescript-mode . rainbow-delimiters-mode)
         (clojurescript-mode . highlight-sexp-mode)
         (clojurescript-mode . highlight-parentheses-mode)
         (clojurescript-mode . prettify-fns)
         (clojurescript-mode . prettify-anonymous-fns)
         (clojurescript-mode . prettify-sets))
  :config
  (progn
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (hack-local-variables)
    (setq clojure-align-forms-automatically 1)))

(defun cider-repl-prompt-custom (namespace)
  "Return a prompt string that mentions NAMESPACE."
  (format "λ %s\n" namespace))

(use-package ac-cider)

(use-package cider
  :hook ((cider-repl-mode . subword-mode)
         (cider-repl-mode . company-mode)
         (cider-repl-mode . ac-cider-setup)
         (cider-repl-mode . smartparens-strict-mode)
         (cider-repl-mode . rainbow-delimiters-mode)
         (cider-repl-mode . set-auto-complete-as-completion-at-point-function)
         (cider-repl-mode . cider-company-enable-fuzzy-completion)

         (cider-mode . subword-mode)
         (cider-mode . company-mode)
         (cider-mode . ac-cider-setup)
         (cider-mode . smartparens-strict-mode)
         (cider-mode . rainbow-delimiters-mode)
         (cider-mode . set-auto-complete-as-completion-at-point-function)
         (cider-mode . cider-company-enable-fuzzy-completion)
         (cider-mode . highlight-parentheses-mode))
  :bind (:map
         cider-mode-map
         ("C-c C-d" . cider-debug-defun-at-point)
         :map
         cider-repl-mode-map
         ("C-c M-o" . cider-repl-clear-buffer))
  :config
  (progn
    (setq cider-repl-pop-to-buffer-on-connect nil
          cider-repl-use-clojure-font-lock nil
          cider-annotate-completion-candidates t
          cider-prompt-for-symbol nil
          cider-repl-use-pretty-printing t
          cider-repl-wrap-history t
          cider-repl-pop-to-buffer-on-connect 'display-only
          cider-repl-prompt-function 'cider-repl-prompt-custom
          cider-repl-result-prefix ";; =>"
          cider-repl-display-in-current-window t
          cider-repl-wrap-history t
          cider-repl-use-pretty-printing 't
          cider-pprint-fn 'puget
          cider-print-options '(("print-color" "true"))
          cider-repl-use-clojure-font-lock t
          cider-auto-select-error-buffer nil
          org-babel-clojure-backend 'cider
          cider-eldoc-display-context-dependent-info t
          cider-save-file-on-load t
          cider-jump-to-pop-to-buffer-actions '((display-buffer-same-window))
          ;; emidje-load-facts-on-eval t
          )
    (define-key clojure-mode-map (kbd "C-t") 'cider-test-rerun-test)
    )
  ;; (eval-after-load 'cider #'emidje-enable-nrepl-middleware)
  )


(use-package clj-refactor
  :config (progn (setq cljr-suppress-middleware-warnings t)
                 (add-hook 'clojure-mode-hook (lambda ()
                                                (clj-refactor-mode 1)
                                                (yas-minor-mode 1)
                                                (cljr-add-keybindings-with-prefix "C-c C-m")))))

(use-package flycheck-joker
  :after clojure-mode
  :ensure t)

(use-package flycheck-clj-kondo
  :ensure t
  :after clojure-mode
  :config
  (dolist (checkers '((clj-kondo-clj . clojure-joker)
                      (clj-kondo-cljs . clojurescript-joker)
                      (clj-kondo-cljc . clojure-joker)
                      (clj-kondo-edn . edn-joker)))
    (flycheck-add-next-checker (car checkers) (cons 'error (cdr checkers)))))

(use-package emidje
 ; :config (eval-after-load 'cider #'emidje-setup)
 )

(use-package kaocha-runner
  :config
  (define-key clojure-mode-map (kbd "C-c k t") 'kaocha-runner-run-test-at-point)
  (define-key clojure-mode-map (kbd "C-c k r") 'kaocha-runner-run-tests)
  (define-key clojure-mode-map (kbd "C-c k a") 'kaocha-runner-run-all-tests)
  (define-key clojure-mode-map (kbd "C-c k w") 'kaocha-runner-show-warnings)
  (define-key clojure-mode-map (kbd "C-c k h") 'kaocha-runner-hide-windows))

(defun set-auto-complete-as-completion-at-point-function ()
  (setq completion-at-point-functions '(auto-complete)))

(use-package clojure-snippets
  :ensure t
  :defer t)
#+END_SRC
*** Kotlin
#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode)

(use-package flycheck-kotlin)

(use-package ob-kotlin)
#+END_SRC
*** Docker
#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :mode ("\\Dockerfile$" . dockerfile-mode))

(use-package docker-compose-mode)
#+END_SRC
*** Elixir
#+BEGIN_SRC emacs-lisp
(defun format-elixir-buffer ()
  "Format elixir buffer."
  (add-hook 'before-save-hook 'elixir-format nil t))

(use-package elixir-mode
  :hook ((elixir-mode . format-elixir-buffer)
         (elixir-mode . flycheck-mix-setup))
  :mode (("\\.ex$" . elixir-mode)
         ("\\.exs$" . elixir-mode)))

(use-package alchemist
  :hook (elixir-mode . alchemist-mode))

(use-package flycheck-mix)
#+END_SRC
*** Java support

We install Java support and setup LSP for Java mode.

#+begin_src emacs-lisp
(use-package lsp-java)
#+end_src

After first run, lsp-java will detect and download Eclipse JDT
Language Server automatically.

*** Debug Adapter Protocol (DAP)

DAP is a wire protocol for communication between the Emacs client and
the Debug Server, similar to LSP.

*** Default configuration

#+begin_src emacs-lisp
(use-package dap-mode
  :after lsp-mode
  :config (progn
            (dap-mode t)
            (dap-ui-mode t)
            (dap-tooltip-mode 1)
            (tooltip-mode 1)))
#+end_src
*** Nginx
#+BEGIN_SRC emacs-lisp
(use-package nginx-mode)
#+END_SRC
*** Python
#+BEGIN_SRC emacs-lisp
(use-package python
  :mode ("\\.py" . python-mode)
  :config (setq python-shell-interpreter "python3"
                py-python-command "python3"))

(use-package elpy
  :hook ((python-mode . elpy-mode)
         (python-mode . elpy-enable))
  :custom
  (elpy-rpc-backend "jedi")
  :bind (:map elpy-mode-map
              ("M-." . elpy-goto-definition)
              ("M-," . pop-tag-mark)
              ("<M-left>" . nil)
              ("<M-right>" . nil)
              ("<M-S-left>" . elpy-nav-indent-shift-left)
              ("<M-S-right>" . elpy-nav-indent-shift-right)
              ("C-c i" . elpy-autopep8-fix-code)
              ("C-c C-d" . elpy-doc)))

(use-package pip-requirements
  :hook ((pip-requirements-mode . #'pip-requirements-auto-complete-setup)))

(use-package py-autopep8
  :hook ((python-mode . py-autopep8-enable-on-save)))

(use-package virtualenvwrapper
  :ensure t
  :config
  (venv-initialize-interactive-shells)
  (venv-initialize-eshell))

(use-package pipenv
  :hook (python-mode . pipenv-mode)
  :init
  (setq pipenv-projectile-after-switch-function
        #'pipenv-projectile-after-switch-extended))

;;(use-package ein)

(use-package hy-mode)
#+END_SRC
*** Rust
#+BEGIN_SRC emacs-lisp
  ;; rust-mode
  ;; https://github.com/rust-lang/rust-mode
(use-package rust-mode
  :bind (:map rust-mode-map
              (("C-c C-t" . racer-describe)))
  :config
  (progn
    ;; add flycheck support for rust
    ;; https://github.com/flycheck/flycheck-rust
    (use-package flycheck-rust
      :after rust-mode
      :hook ((rust-mode . flycheck-rust-setup)))

    ;; cargo-mode for all the cargo related operations
    ;; https://github.com/kwrooijen/cargo.el
    (use-package cargo
      :hook ((rust-mode . cargo-minor-mode)))

    ;; racer-mode for getting IDE like features for rust-mode
    ;; https://github.com/racer-rust/emacs-racer
    (use-package racer
      :hook ((rust-mode . racer-mode)
             (racer-mode . eldoc-mode))
      :config
      (progn
        ;; set racer rust source path environment variable
        (setq racer-rust-src-path "/home/ianffcs/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src")
        (defun my-racer-mode-hook ()
          (set (make-local-variable 'company-backends)
               '((company-capf company-files))))
        (define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common))

      ;; enable company and eldoc minor modes in rust-mode
      (add-hook 'racer-mode-hook 'company-mode)
      (add-hook 'racer-mode-hook 'eldoc-mode)))
  (add-hook 'rust-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c <tab>") #'rust-format-buffer)))
  (add-hook 'rust-mode-hook 'flycheck-mode)
  (add-hook 'flycheck-mode-hook 'flycheck-rust-setup)
  (add-hook 'rust-mode-hook 'racer-mode)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)

  ;; format rust buffers on save using rustfmt
  (add-hook 'before-save-hook
            (lambda ()
              (when (eq major-mode 'rust-mode)
                (rust-format-buffer)))))
#+END_SRC
*** Haskell
#+BEGIN_SRC emacs-lisp

(use-package lsp-haskell
 :ensure t
 :config
 (setq lsp-haskell-process-path-hie "ghcide"
       lsp-haskell-process-args-hie '())
  ;; Comment/uncomment this line to see interactions between lsp client/server.
 ;; (setq lsp-log-io t)
 )

(use-package haskell-mode
  :ensure t
  :hook (haskell-mode . interactive-haskell-mode))

(use-package eglot
  :ensure t
  :config
  (add-to-list 'eglot-server-programs '(haskell-mode . ("ghcide" "--lsp"))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (use-package intero                                            ;;
;;   :ensure t :config                                            ;;
;;   (progn                                                       ;;
;;     (add-hook 'haskell-mode-hook 'intero-mode)))               ;;
;;                                                                ;;
;; (setq flycheck-check-syntax-automatically '(save new-line))    ;;
;; (flycheck-add-next-checker 'intero '(warning . haskell-hlint)) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#+END_SRC
*** WebMode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.vue?\\'" . web-mode))
  (setq web-mode-engines-alist
        '(("django"    . "\\.html\\'")))
  (setq web-mode-ac-sources-alist
        '(("css" . (ac-source-css-property))
          ("vue" . (ac-source-words-in-buffer ac-source-abbrev))
          ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

(setq web-mode-enable-auto-closing t))
(setq web-mode-enable-auto-quoting t) ; this fixes the quote problem I mentioned
#+END_SRC
*** JS
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :ensure ac-js2
  :init
  (progn
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (add-hook 'js2-mode-hook 'ac-js2-mode)))

(use-package js2-refactor
  :ensure t
  :config
  (progn
    (js2r-add-keybindings-with-prefix "C-c C-m")
;; eg. extract function with `C-c C-m ef`.
    (add-hook 'js2-mode-hook #'js2-refactor-mode)))

(use-package tern
  :ensure tern
  :ensure tern-auto-complete
  :config
  (progn
    (add-hook 'js-mode-hook (lambda () (tern-mode t)))
    (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    ;;(tern-ac-setup)
))

;;(use-package jade
;;:ensure t
;;)

;; use web-mode for .jsx files
(add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))


;; turn on flychecking globally
(add-hook 'after-init-hook #'global-flycheck-mode)

;; disable jshint since we prefer eslint checking
(setq-default flycheck-disabled-checkers
  (append flycheck-disabled-checkers
    '(javascript-jshint)))

;; use eslint with web-mode for jsx files
(flycheck-add-mode 'javascript-eslint 'web-mode)

;; customize flycheck temp file prefix
(setq-default flycheck-temp-prefix ".flycheck")

;; disable json-jsonlist checking for json files
(setq-default flycheck-disabled-checkers
  (append flycheck-disabled-checkers
    '(json-jsonlist)))

;; adjust indents for web-mode to 2 spaces
(defun my-web-mode-hook ()
  "Hooks for Web mode. Adjust indents"
  ;;; http://web-mode.org/
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))

(add-hook 'web-mode-hook  'my-web-mode-hook)

(use-package company-web
  :after web-mode)

(use-package rjsx-mode
  :mode ("\\.jsx$" . rjsx-mode)
  :magic ("%React" . rjsx-mode))

(use-package vue-mode
  :mode
  ("\\.vue$" . vue-mode))

(use-package indium
  :after js2-mode
  :hook ((js2-mode . indium-interaction-mode))
  :bind (:map indium-interaction-mode-map
              ("C-x C-e" . indium-eval-last-node)
              ("C-<f6>" . vs/stop-indium-debug)
              ("S-<f6>" . indium-connect)
              ("<f6>" . indium-launch))
  :config (delight indium-interaction-mode))

(use-package mocha
  :init (setq mocha-reporter "spec")
  :bind (:map js2-mode-map
              (("C-c t" . mocha-test-project))))

(use-package json-mode
  :mode
  ("\\.json$" . json-mode))
#+END_SRC
*** Latex
#+BEGIN_SRC emacs-lisp
  ;; (use-package tex
    ;; :ensure t)

  ;; (use-package cdlatex
  ;;   :ensure t)

  ;; ;;
  ;(use-package auctex
  ;;   :ensure t
  ;;   :config (setq TeX-auto-save t)
  ;;   (setq TeX-parse-self t)
  ;;   (setq TeX-close-quote "")
  ;;   (setq TeX-open-quote ""))


  ;; (defcustom
  ;;   prelude-latex-fast-math-entry 'LaTeX-math-mode
  ;;   "Method used for fast math symbol entry in LaTeX."
  ;;   :link '(function-link :tag "AUCTeX Math Mode" LaTeX-math-mode)
  ;;   :link '(emacs-commentary-link :tag "CDLaTeX" "cdlatex.el")
  ;;   :group 'prelude
  ;;   :type '(choice (const :tag "None" nil)
  ;;                  (const :tag "AUCTeX Math Mode" LaTeX-math-mode)
  ;; (const :tag "CDLaTeX" cdlatex)))

  ;; (defun tex-view ()
  ;;   (interactive)
  ;;   (tex-send-command "evince" (tex-append tex-print-file ".pdf")))

  ;; (require 'latex-pretty-symbols)
  ;; (add-hook 'markdown-mode-hook 'pandoc-mode)
  ;; (add-hook 'markdown-mode-hook 'latex-unicode-simplified)
  ;; (setq markdown-enable-math 1)
  ;; (add-hook 'org-mode-hook 'latex-unicode-simplified)

  ;; (eval-after-load "tex"
  ;;   '(add-to-list 'TeX-command-list '("latexmk" "latexmk -synctex=1 -shell-escape -pdf %s" TeX-run-TeX nil t :help "Process file with latexmk")))
  ;; (eval-after-load "tex"
  ;;   '(add-to-list 'TeX-command-list '("xelatexmk" "latexmk -synctex=1 -shell-escape -xelatex %s" TeX-run-TeX nil t :help "Process file with xelatexmk")))
  ;; (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
#+END_SRC
*** Scheme
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :ensure t
  :hook ((geiser-repl-mode . subword-mode)
         (geiser-repl-mode . company-mode)
         (geiser-repl-mode . smartparens-strict-mode)
         (geiser-repl-mode . rainbow-delimiters-mode)
         (geiser-repl-mode . highlight-parentheses-mode)
         (geiser-mode . smartparens-strict-mode)
         (geiser-mode . rainbow-delimiters-mode)
         (geiser-mode . highlight-parentheses-mode))
  :config (setq geiser-mode-start-repl-p t
                geiser-active-implementations '(guile racket)))
#+END_SRC
*** TeX

I used to use latex-preview-pane for comfortable editing, but not
anymore...

#+begin_src emacs-lisp :tangle no
;; (use-package latex-preview-pane
;;   :config
;;   (when (display-graphic-p)
;;     (latex-preview-pane-enable)))
#+end_src

To compile the current file, we resort to Rubber, an external tool.

#+begin_src emacs-lisp
(defun rubber-compile-file ()
  (interactive)
  (shell-command
   (concat "rubber -d " buffer-file-name))
  (message "Finished LaTeX compilation."))
#+end_src

It is also interesting to have pretty symbols for our LaTeX files.

#+begin_src emacs-lisp
  (use-package latex-pretty-symbols)
#+end_src

*** R
#+begin_src emacs-lisp
(use-package ess
  :ensure t)
#+end_src
*** CSS
*** CSV
#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :ensure t
  :config
  (setq csv-separators '("," ";" "|" " " )))
#+END_SRC

*** Plantuml
#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode ("\\.plantuml\\'" . plantuml-mode)
  :config
  (let ((plantuml-directory (concat user-emacs-directory "private/"))
        (plantuml-link "http://sourceforge.net/projects/plantuml/files/plantuml.jar/download"))
    (let ((plantuml-target (concat plantuml-directory "plantuml.jar")))
      (if (not (file-exists-p plantuml-target))
          (progn (message "Downloading plantuml.jar")
                 (shell-command
                  (mapconcat 'identity (list "wget" plantuml-link "-O" plantuml-target) " "))
                 (kill-buffer "*Shell Command Output*")))
      (setq org-plantuml-jar-path plantuml-target
            plantuml-jar-path plantuml-target
            plantuml-output-type "svg"))))

(use-package flycheck-plantuml
  :config (flycheck-plantuml-setup))

#+END_SRC
*** Go
#+BEGIN_SRC emacs-lisp
  (defvar jong-go-debug-buffer "*jong-go-debug*" "Jong go language debug buffer.")

  (use-package go-mode
    :init (add-hook 'go-mode-hook
                    (lambda ()
                      ;;(setq gofmt-command "goimports")
                      (add-hook 'before-save-hook 'lsp-organize-imports nil t)
                      (setq truncate-lines t)
                      (setq indent-tabs-mode t)
                      (setq tab-width 4)))
    :config
    (progn
      (add-to-list 'auto-mode-alist (cons "\\.go\\'" 'go-mode))))


  (use-package go-guru
          :ensure t)

  (use-package company-go
          :ensure t)

  (use-package go-eldoc
          :ensure t
          :config
          (add-hook 'go-mode-hook 'go-eldoc-setup))

  (use-package go-complete
          :ensure t
          :config
          (add-hook 'completion-at-point 'go-complete-at-point))

  (defun my-go-mode-hook ()
    ;; prefer goimports, if present
    (if (executable-find "goimports")
        (setq gofmt-command "goimports"))

    ;; Format code when we save
    (add-hook 'before-save-hook 'gofmt-before-save)

    ;; esc-space to jump to definition
    (local-set-key (kbd "M-SPC") 'godef-jump)
    ;; escp-b to jump (b)ack
    (local-set-key (kbd "M-b") 'pop-tag-mark))

  (add-hook 'go-mode-hook 'my-go-mode-hook)

  (use-package go-dlv
          :ensure t)

  (use-package gotest
          :ensure t)

  (defun jong-set-go-envs()
          "Set environment variables relative with go."
          (interactive)
          (when (memq window-system '(mac ns x))
                  (exec-path-from-shell-copy-envs '("PATH" "GOROOT" "GOPATH")))
          )

  (add-to-list 'exec-path (expand-file-name (format "%s/bin" (getenv "GOPATH"))))

  (defun jong-go-chan-gud-stepout ()
          "This is ..."
          (interactive)
          (let ((current-buffer-name (buffer-name))
                                  (gud-buffer-pattern "^\*gud-.*")
                                  (target-buffer nil)
                                  (temp-buffer-list (buffer-list)))
                  ;; Current buffer is gud.
                  (if (and (string-match gud-buffer-pattern current-buffer-name)
                                                   (equal major-mode 'jong-gogud-mode))
                                  (setq target-buffer (current-buffer))
                          (catch 'loop
                                  (dolist (buffer temp-buffer-list)
                                          (with-current-buffer buffer
                                                  (when (and (string-match gud-buffer-pattern (buffer-name buffer))
                                                                                           (equal major-mode 'jong-gogud-mode))
                                                          (setq target-buffer buffer)
                                                          (message "im here!!!")
                                                          (throw 'loop buffer))))))

                  (when target-buffer
                          (with-current-buffer target-buffer
                                  (goto-char (point-max))
                                  (send-string (get-buffer-process (current-buffer)) "stepout\n")))
                  ))


  (defun jong-go-set-gud-shortcut ()
          "Set shortcuts of gud for golang."

          (local-set-key (kbd "<f7>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-print)
                                                                                                                                  (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f8>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-cont)))

          (local-set-key (kbd "<f9>") (lambda () (interactive)
                                                                                                                                  (call-interactively 'gud-break)))

          (local-set-key (kbd "<f10>") (lambda () (interactive)
                                                                                                                                   (call-interactively 'gud-next)
                                                                                                                                   (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f11>") (lambda () (interactive)
                                                                                                                                   (call-interactively 'gud-step)
                                                                                                                                   (call-interactively 'end-of-buffer)))

          (local-set-key (kbd "<f12>") 'jong-go-chan-gud-stepout))


  (defun jong-get-imported-packages ()
          "Get Imported package "
          (interactive)
          (let ((output-buffer "*jong-output-buffer*")
                                  (extract-pattern-whole "^[[:space:]]*import[[:space:]]*(\\([[:ascii:]]+?\\))")
                                  (extract-pattern-elem "^[[:space:]]*\\([[:alpha:]]+\\)[[:space:]]*\\([\\\s_\\\s-\\\s\"\\\s.\\\s/[[:alpha:]]*]*\\)")
                                  (imported-string "")
                                  (base-pos (point))
                                  (package-url-list nil)
                                  (import-start-pattern "^.*import.*[(]")
                                  (import-end-pattern ".*)")
                                  (extension (file-name-extension (buffer-file-name)))
                                  (buffer-temp nil)
                                  (command nil)
                                  (imported-packages))
                  (unless (equal extension "go")
                          (error "This file is not for golang"))

                  (string-match extract-pattern-whole (buffer-substring-no-properties (point-min) (point-max)))
                  (setq imported-string (match-string 1 (buffer-substring-no-properties (point-min) (point-max))))
                  (setq imported-packages (split-string imported-string "\n"))
                  (with-current-buffer (get-buffer-create output-buffer)
                          (progn
                                  (dolist (package-uri imported-packages)
                                          (if (string-match extract-pattern-elem package-uri)
                                                          (progn
                                                                  (when (match-string 1 package-uri)
                                                                          (insert (format "%s\n" (match-string 1 package-uri)))
                                                                          (start-process-shell-command "go"
                                                                                                                                                                                           (current-buffer)
                                                                                                                                                                                           (format "go get %s" (match-string 1 package-uri))))
                                                                  (when (match-string 2 package-uri)
                                                                          (insert (format "%s\n" (match-string 2 package-uri)))
                                                                          (start-process-shell-command "go"
                                                                                                                                                                                           (current-buffer)
                                                                                                                                                                                           (format "go get %s" (match-string 2 package-uri)))))
                                                  (start-process-shell-command "go"
                                                                                                                                                                   (current-buffer)
                                                                                                                                                                   (format "go get %s" package-uri)))
                                          )
                                  )
                          )
                  )
          )


  (defun jong-set-go-bins ()
          "Check if GOPATH environment variable is set or not.
  And the environment variable was existing, Download go binaries from the internet..."
          (interactive)
          (let ((cmd nil)
                                  (buffer-name "*jong-set-go-bins*")
                                  (list-url (list "github.com/golang/lint/golint"
                                                                                                  "github.com/mdempsky/gocode"
                                                                                                  "github.com/k0kubun/pp"
                                                                                                  "github.com/golang/lint/golint"
                                                                                                  "github.com/rogpeppe/godef"
                                                                                                  "github.com/dougm/goflymake"
                                                                                                  "golang.org/x/tools/cmd/vet"
                                                                                                  "golang.org/x/tools/cmd/godoc"
                                                                                                  "golang.org/x/tools/cmd/guru"
                                                                                                  "golang.org/x/tools/cmd/goimports"
                                                                                                  "golang.org/x/tools/gopls@latest"
                                                                                                  "github.com/go-delve/delve/cmd/dlv")))
                  (if (getenv "GOPATH")
                                  (progn
                                          (dolist (elt list-url cmd)
                                                  (setq cmd (format "go get -u %s" elt))
                                                  (with-current-buffer (get-buffer-create buffer-name)
                                                          (shell-command cmd (current-buffer) (current-buffer)))))
                          (message "There was not the GOPATH environment variable."))
                  )
          )


  (setq gofmt-command "goimports")

  (add-hook 'go-mode-hook 'go-eldoc-setup)
  (add-hook 'go-mode-hook (lambda ()
                                                                                                          (setq gofmt-command "goimports")
                                                                                                          (if (not (string-match "go" compile-command))
                                                                                                                          (set (make-local-variable 'compile-command)
                                                                                                                                           "go build -v && go test -v && go vet"))))

  (defun jong-go-debug-project ()
          "Debug the go project with delve."
          (interactive)
          (let ((cmd nil)
                                  (homedir nil))
                  (setq homedir (projectile-project-root))
                  (if homedir
                                  (with-temp-buffer
                                          (cd homedir)
                                          (call-interactively 'dlv))
                          (message "Couldn't found the projectile root directory."))
                  ))

  (defcustom jong-go-run-command nil
          "This is varialbe for project run."
          :type 'string)

  (defcustom jong-go-run-default-path nil
          "This is varialbe for project default directory."
          :type 'string)

  (defun jong-go-set-project-run-command ()
          (interactive)
          (let ((command))
                  (setq command (read-string "Enter the command : "))
                  (setq jong-go-run-command command)
                  (setq jong-go-run-default-path default-directory)
                  (message "Next run command : [%s], default path : [%s]"
                                                   jong-go-run-command jong-go-run-default-path)
                  )
          )

  (defun jong-go-run-project ()
          (interactive )
          (let ((output-buffer-name "*jong-output*")
                                  (output-buffer nil)
                                  (program-name nil)
                                  (program-args nil))
                  (ignore-errors (kill-buffer output-buffer-name))
                  (with-current-buffer (get-buffer-create output-buffer-name)
                          (if jong-go-run-command
                                          (progn
                                                  (display-buffer (current-buffer))
                                                  (setq default-directory jong-go-run-default-path)
                                                  (async-shell-command jong-go-run-command (current-buffer) (current-buffer)))
                                  (start-process jong-go-run-command (current-buffer) program-name program-args))
                          (message "The command was not setted.")))
          )

  (defun jong-go-run-project-otherframe ()
          (interactive)
          (let ((current-frame (selected-frame))
                                  (output-buffer-name "*jong-output*")
                                  (output-frame-name "log-frame")
                                  (output-buffer nil)
                                  (output-frame nil)
                                  (program-name nil)
                                  (program-args nil))

                  (ignore-errors (kill-buffer output-buffer-name))
                  (setq output-buffer (get-buffer-create output-buffer-name))
                  (if (setq output-frame

                                                          (catch 'found
                                                                  (dolist (frame (frame-list))
                                                                          (if (equal output-frame-name (frame-parameter frame 'name))
                                                                                          (throw 'found frame)))))
                                  (progn
                                          (select-frame-set-input-focus output-frame)
                                          (switch-to-buffer output-buffer-name))
                          (progn
                                  (setq output-frame (make-frame
                                                                                                                  '((name . "log-frame"))
                                                                                                                  ))
                                  (select-frame-set-input-focus output-frame)
                                  (switch-to-buffer output-buffer-name)))
                  (with-current-buffer (get-buffer output-buffer)
                          (if jong-go-run-command
                                          (progn
                                                  (setq default-directory jong-go-run-default-path)
                                                  (async-shell-command jong-go-run-command (current-buffer) (current-buffer)))
                                  (message "go-run-command was not setted...")))
                  (select-frame-set-input-focus current-frame)
                  )
          )


  (define-derived-mode jong-gogud-mode gud-mode "jong-gogud"
          (setq font-lock-defaults '(go--build-font-lock-keywords)))


  (defun chan-gogud-exec-function (target-func)
          "..."
          (interactive)
          (let ((base-line 0)
                                  (target-line 0)
                                  (current-line-buffer "")
                                  (target-symbol "")
                                  (target-offset 0))

                  ;; Initailize other buffer cursor position...
                  (gud-refresh)

                  ;; Get Initial variables...
                  (setq target-line (line-number-at-pos))
                  (setq target-symbol (thing-at-point 'symbol))
                  (if (equal target-symbol nil)
                                  (progn
                                          (message "Target symbol was nil...")
                                          (return)))

                  ;; Get current line buffer...
                  (setq current-line-buffer (buffer-substring-no-properties
                                                                                                                           (line-beginning-position)
                                                                                                                           (line-end-position)))

                  ;; Calculates what times symbol was shown from the line...
                  (setq target-offset
                                          (- (- (- (point) (line-beginning-position))
                                                                  (string-match ":" current-line-buffer)) 2))


                  ;; Get base-line from the gud buffer.
                  (goto-char (point-max))
                  (while (not (string-prefix-p "=>" (current-line-contents)))
                          (forward-line -1)
                          (if (equal (point) 0)
                                          (progn
                                                  (message "Couldnt find the '=>' prefix...")
                                                  (return))))

                  (setq base-line (line-number-at-pos))

                  ;; Move other window and move the point to the target symbol.
                  (other-window 1)
                  (forward-line (- target-line base-line))
                  (line-beginning-position)
                  (goto-char (+ (point) target-offset))
                  (call-interactively target-func)
                  (other-window 1)
                  (with-no-warnings
                          (goto-line target-line))
                  )
          )


  (defun jong-gogud-gdb (&optional cmd)
          "This is delve wrapper based on 'gud-gdb mode."
          (interactive)
          (let ((cmd))
                  (with-current-buffer (current-buffer)
                          (setq cmd (read-string "dlv command :" "dlv exec"))
                          (when (equal cmd nil)
                                  (setq cmd "dlv debug"))
                          (dlv cmd)
                          (jong-gogud-mode)
                          ))
          )


  (defun chan-run-dlv-client(&optional port)
          "Connect the dlv server!!!."
          (interactive)
          (let ((target-port "")
                                  (output-buffer "*gud-connect*")
                                  (process-name nil)
                                  (waiting-seconds 0))

                  (when (get-buffer output-buffer)
                          (with-current-buffer (get-buffer output-buffer)
                                  (while (get-buffer-process (current-buffer))
                                          (comint-send-eof)
                                          (message "waiting killing the gud-connect process. (%d seconds)" waiting-seconds)
                                          (sleep-for 1)
                                          (1+ waiting-seconds))

                                  (kill-buffer (current-buffer))))

                  (if (equal port nil)
                                  (setq target-port (read-string "input listen port : "))
                          (setq target-port port))
                  (dlv (format "dlv connect :%s" target-port))
                  (jong-gogud-mode))
          )


  (defun chan-run-dlv-server()
          "Make run interactively!!!."
          (interactive)
          (let ((target-dir nil)
                                  (output-buffer "*chan-dlv-server*")
                                  (process-name nil)
                                  (listen-process nil))

                  (if (get-buffer output-buffer)
                                  (kill-buffer output-buffer))

                  (if (equal (projectile-project-root) nil)
                                  (setq target-dir (projectile-project-root))
                          (setq target-dir default-directory))

                  ;; start headless delve
                  (with-current-buffer (get-buffer-create output-buffer)
                          (when (get-buffer-process (current-buffer))
                                  (interrupt-process process-name)
                                  (while (get-buffer-process (current-buffer))
                                          (message "Killing process : %s " process-name)
                                          (sleep-for 1))
                                  (comint-clear-buffer))

                          (display-buffer output-buffer)
                          (setq default-directory target-dir)
                          (ignore-errors (term-mode))
                          (start-process "dlv-server-debug" (current-buffer) "dlv" "debug" "--headless")
                          (ignore-errors (term-mode)))
                  )
          )


  (defun chan-run-dlv-cs (&optional otherframe)
          "Create dlv with server and client mode."
          (interactive)
          (let ((port)
                                  (start-pos)
                                  (end-pos)
                                  (magic-seconds 20)
                                  (main-file "main.go")
                                  (log-frame "log-frame")
                                  (input-frame "input-frame")
                                  (target-frame)
                                  (current-frame (selected-frame)))
                  (catch 'exit
                          (condition-case ex
                                          (progn
                                                  ;; Run server dlv process.
                                                  (with-current-buffer (get-buffer main-file)
                                                          (chan-run-dlv-server))
                                                  ;; Waiting a server process reveal.
                                                  (setq port (with-current-buffer (get-buffer "*chan-dlv-server*")
                                                                                                   (while (< (length (buffer-string)) 1)
                                                                                                           (message "waiting the seconds : %d"
                                                                                                                                                  (setq magic-seconds (1- magic-seconds)))
                                                                                                           (sleep-for 1)
                                                                                                           (when (equal magic-seconds 0)
                                                                                                                   (throw 'exit magic-seconds)))
                                                                                                   (goto-char (point-max))
                                                                                                   (forward-line -1)
                                                                                                   (end-of-line)
                                                                                                   (setq end-pos (point))
                                                                                                   (re-search-backward ":")
                                                                                                   (setq start-pos (1+ (point)))
                                                                                                   (buffer-substring start-pos end-pos)))
                                                  ;; Run client dlv process.
                                                  (with-current-buffer (get-buffer main-file)
                                                          (chan-run-dlv-client port)))
                                  (message "There was not a main.go buffer."))
                          (progn
                                  (message "Waiting time was gone...")
                                  nil))

                  (when otherframe
                          (if (setq target-frame
                                                                  (catch 'target
                                                                          (dolist (frame (frame-list))
                                                                                  (if (equal log-frame (frame-parameter frame 'name))
                                                                                                  (throw 'target frame)))))
                                          (progn
                                                  (select-frame-set-input-focus target-frame)
                                                  (switch-to-buffer "*chan-dlv-server*")
                                                  (select-frame-set-input-focus current-frame)
                                                  (switch-to-buffer-other-window main-file)
                                                  (other-window 1)
                                                  )
                                  (progn
                                          (setq target-frame (make-frame
                                                                                                                          '((name . "log-frame"))
                                                                                                                          ))
                                          (select-frame-set-input-focus target-frame)
                                          (switch-to-buffer "*chan-dlv-server*")
                                          (select-frame-set-input-focus current-frame)
                                          (switch-to-buffer-other-window main-file)
                                          (other-window 1)
                                          )))
                  )
          )

  (defun jong-run-dlv-cs-otherframe ()
          "Create dlv with server (other-frame) and client mode."
          (interactive)
          (chan-run-dlv-cs t))


  ;; (add-hook 'go-mode-hook 'jong-go-set-gud-shortcut)
  (add-hook 'go-mode-hook (lambda ()
                                                                                                          (setq lsp-ui-sideline-enable nil)
                                                                                                          (setq lsp-ui-doc-enable nil)
                                                                                                          (setq lsp-gopls-staticcheck t)
                                                                                                          (setq lsp-eldoc-render-all t)
                                                                                                          (setq lsp-gopls-complete-unimported t)
                                                                                                          (lsp)

                                                                                                          (setq indent-tabs-mode t)
                                                                                                          (setq tab-width 4)

                                                                                                          ;; syntax highlight
                                                                                                          (go-guru-hl-identifier-mode)

                                                                                                          ;; setting company-go mode...
                                                                                                          (setq company-tooltip-limit 20)
                                                                                                          (setq company-idle-delay .3)
                                                                                                          (setq company-echo-delay 0)
                                                                                                          (setq company-begin-commands '(self-insert-command))
                                                                                                          (set (make-local-variable 'company-backends) '(company-go))
                                                                                                          (company-mode)

                                                                                                          ;;setting go-eldocp
                                                                                                          (set-face-attribute 'eldoc-highlight-function-argument nil
                                                                                                                                                                                          :underline t :foreground "green"
                                                                                                                                                                                          :weight 'bold)
                                                                                                          (local-set-key (kbd "C-c r w") 'lsp-workspace-restart)
                                                                                                          (local-set-key (kbd "C-c C-r") 'go-remove-unused-imports)
                                                                                                          (local-set-key (kbd "C-c C-a") 'go-import-add)
                                                                                                          (local-set-key (kbd "C-c C-g") 'go-goto-imports)
                                                                                                          (local-set-key (kbd "C-c C-f") 'gofmt)
                                                                                                          (local-set-key (kbd "C-c r .") 'lsp-find-definition)
                                                                                                          (local-set-key (kbd "C-c r ,") 'lsp-find-references)
                                                                                                          (local-set-key (kbd "C-c r i") 'lsp-find-implementation)
                                                                                                          (local-set-key (kbd "C-c r j") 'go-guru-definition)
                                                                                                          (local-set-key (kbd "C-c r d") 'go-guru-describe)
                                                                                                          (local-set-key (kbd "C-c o i") 'lsp-organize-imports)
                                                                                                          (local-set-key (kbd "C-c r l") 'helm-imenu)
                                                                                                          (local-set-key (kbd "C-c g g")
                                                                                                                                                                   (lambda () (interactive)
                                                                                                                                                                           (jong-gogud-gdb "dlv debug")))
                                                                                                          (local-set-key (kbd "C-c g i") 'jong-get-imported-packages)
                                                                                                          (local-set-key (kbd "C-c s f") 'gofmt-before-save)
                                                                                                          (local-set-key (kbd "C-c g c") 'chan-run-dlv-cs)
                                                                                                          (local-set-key (kbd "C-c c c") 'jong-project-compile-project)
                                                                                                          ;; (compile "go build -v && go test -v && go vet")))
                                                                                                          (local-set-key (kbd "C-c r r") 'lsp-rename)
                                                                                                          (local-set-key (kbd "C-c t f") 'go-test-current-test)
                                                                                                          (local-set-key (kbd "C-c t a") 'go-test-current-file)

                                                                                                          ;; (local-set-key (kbd "C-c r r") 'jong-go-run-project-otherframe)
                                                                                                          (local-set-key (kbd "C-c r s") 'jong-go-set-project-run-command)
                                                                                                          (local-set-key (kbd "C-c M->")
                                                                                                                                                                   (lambda () (interactive)
                                                                                                                                                                           (other-window 1)
                                                                                                                                                                           (call-interactively 'end-of-buffer)
                                                                                                                                                                           (other-window -1)))
                                                                                                          )
                                          )


  ;; (add-hook 'chan-gogud-mode-hook 'jong-go-set-gud-shortcut)
  (add-hook 'chan-gogud-mode-hook
                                          (lambda () (local-set-key (kbd "C-c r .")
                                                                                                                                                  (lambda () (interactive)
                                                                                                                                                          (call-interactively 'gud-refresh)
                                                                                                                                                          (chan-gogud-exec-function #'godef-jump)))
                                                  (local-set-key (kbd "C-c r ,")
                                                                                                           (lambda () (interactive)
                                                                                                                   (call-interactively 'gud-refresh)
                                                                                                                   (chan-gogud-exec-function #'go-guru-referrers)))
                                                  (local-set-key (kbd "C-c r i")
                                                                                                           (lambda () (interactive)
                                                                                                                   (call-interactively 'gud-refresh)
                                                                                                                   (chan-gogud-exec-function #'go-guru-implements)))
                                                  ))
#+END_SRC
* Pretty Mode
#+BEGIN_SRC emacs-lisp
(use-package pretty-mode
  :ensure t
  :config
  (add-hook 'clojure-mode-hook #'turn-on-pretty-mode))
#+END_SRC

* Private
#+BEGIN_SRC emacs-lisp
(defconst private-dir (expand-file-name "private" user-emacs-directory))
(defconst temp-dir (format "%s/cache" private-dir))

(unless (file-exists-p private-dir)
  (make-directory private-dir :parents))

(unless (file-exists-p temp-dir)
  (make-directory temp-dir :parents))
#+END_SRC
* Alerts
** Alert

  Alert is a growl-workalike for Emacs which uses a common
  notification interface and multiple, selectable styles, whose use is
  fully customized by the user.

  #+BEGIN_SRC emacs-lisp
    (use-package alert
      :config
      (setq alert-default-style 'libnotify
            alert-log-messages t))

    (require 'alert)
  #+END_SRC

** User configuration

   Several packages uses Alert for sending notifications, so you have
   full control over them by customizing =alert-user-configuration=.

*** Slack notifications
    This was stolen from [[https://endlessparentheses.com/keep-your-slack-distractions-under-control-with-emacs.html][endless parentheses]] and adapt accordingly.

    Channels that I wish to only log the messages in the *Alert*
    buffer.
    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'alert
        '(add-to-list 'alert-user-configuration
                      '(((:title . "\\(beginners\\|datomic\\|clojure\\|clojurescript\\|off-topic\\|datascript\\|core-async\\)")
                         (:category . "slack"))
                        log nil)))
    #+END_SRC

    However, there are a couple of important channels I would like to
    be notified about anything, so add a rule for them.
    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'alert
        '(add-to-list 'alert-user-configuration
                      '(((:title . "\\(reitit\\|sql\\)")
                         (:category . "slack"))
                        libnotify nil)))
    #+END_SRC

    There are a few channel where I only need to pay attention if
    explicitly mentioned.
    #+BEGIN_SRC emacs-lisp
      (add-to-list
       'alert-user-configuration
       '(((:message . "@bartuka\\|Wanderson")
          (:title . "\\(beginners\\)")
          (:category . "slack"))
         libnotify nil))
    #+END_SRC

*** Telegram notifications

    Let's start by telling alert *not* to notify anything.
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'alert-user-configuration
                   '(((:category . "telega"))
                     log nil))
    #+END_SRC

    However, if someone explicitly mention me, tell me pls.
    #+BEGIN_SRC emacs-lisp
      (add-to-list
             'alert-user-configuration
             '(((:message . "@bartuka\\|Wanderson")
                (:category . "telega"))
               libnotify nil))
    #+END_SRC
* Org
** Org General confs
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :hook ((org-mode . toggle-word-wrap)
         (org-mode . org-indent-mode)
         (org-mode . turn-on-visual-line-mode)
         (org-mode . (lambda () (display-line-numbers-mode -1)))
         (org-mode . auto-revert-mode))
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda))
  :config
  (setq ;org-default-notes-file (concat org-directory "~/sync/orgfiles/notes.org.gpg")
   org-export-html-postamble nil
   org-hide-leading-stars t
   org-startup-indented t
   org-journal-dir "~/sync/orgfiles"
   org-display-inline-images t
   org-redisplay-inline-images t
   org-startup-with-inline-images "inlineimages"
    ;org-agenda-files (list "~/sync/orgfiles/life.org.gpg" "~/sync/orgfiles/personal_cal.org.gpg" "~/sync/orgfiles/work_cal.org.gpg")
   org-todo-keywords '((sequence "TODO(t)" "PENDING(p!)" "WAIT(w@)" "VERIFY(v)" "|" "DONE(d!)" "CANCELED(c@)")
                       (sequence "REPORT(r@)" "BUG(b@)" "KNOWNCAUSE(k@)" "|" "FIXED(f!)"))
   org-edit-src-content-indentation 0
   org-src-tab-acts-natively t
   org-src-fontify-natively t
   org-confirm-babel-evaluate nil
   org-support-shift-select 'always
   org-hide-emphasis-markers        t
   org-edit-src-content-indentation 0
   org-src-tab-acts-natively        t
   org-src-fontify-natively         t
   org-src-preserve-indentation     t
   org-file-apps '((auto-mode . emacs)
                   ("\\.mm\\'" . default)
                   ("\\.x?html?\\'" . "/usr/bin/firefox %s")
                   ;;("\\.pdf\\'" . "/usr/bin/zathura %s")
                   )
   org-hide-emphasis-markers t
   org-babel-clojure-nrepl-timeout nil
   org-export-allow-bind-keywords t
   org-confirm-babel-evaluate       t)

  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
  (defun do-org-show-all-inline-images ()
    (interactive)
    (org-display-inline-images t t))
  (global-set-key (kbd "C-c C-x C v")
                  'do-org-show-all-inline-images)

  (use-package ob-restclient)
  (use-package ob-hy)
  (use-package ob-ipython)
  (use-package ob-prolog)
  (use-package ob-async
    :init (setq ob-async-no-async-languages-alist '("ipython")))
  (use-package ox-reveal)

  (org-defkey org-mode-map "\C-x\C-e" 'cider-eval-last-sexp)
  (org-defkey org-mode-map "\C-c\C-d" 'cider-doc))

    ;; (use-package org-gcal
         ;; :init (load-library "~/.gcal.el.gpg")
         ;; :config (setq org-gcal-file-alist '(("maximoiann@gmail.com" .  "~/sync/orgfiles/personal_cal.org")
                             ;; ("ian@crowd.br.com" . "~/sync/orgfiles/work_cal.org"))))
;; organize journal confs after
#+END_SRC
** Agenda
#+BEGIN_SRC emacs-lisp
(require 'org-agenda)

(use-package calendar
  :ensure nil
  :hook (calendar-today-visible . calendar-mark-today)
  :config
  (setq calendar-latitude -23.5475
        calendar-longitude -46.63611
        calendar-location-name "Sao_Paulo, Brazil")
  (setq calendar-holiday-marker t))

(setq org-agenda-include-diary t
      calendar-week-start-day 0
      calendar-day-name-array ["Domingo" "Segunda" "Terça" "Quarta"
                               "Quinta" "Sexta" "Sábado"]
      calendar-month-name-array ["Janeiro" "Fevereiro" "Março" "Abril"
                                 "Maio" "Junho" "Julho" "Agosto"
                                 "Setembro" "Outubro" "Novembro" "Dezembro"])

(add-to-list 'org-agenda-custom-commands
             '("Y" "Agenda anual de aniversários e feriados" agenda "Visão Anual"
               ((org-agenda-span 365)
                (org-agenda-filter-by-category 'Aniversário)
                (org-agenda-time-grid nil))))
(add-to-list 'org-agenda-custom-commands
             '("1" "Agenda mensal" agenda "Visão Mensal"
               ((org-agenda-span 31)
                (org-agenda-time-grid nil))))
(add-to-list 'org-agenda-custom-commands
             '("7" "Agenda dos próximos sete dias" agenda "Visão de Sete Dias"
               ((org-agenda-span 7)
                (org-agenda-time-grid nil))))

(load (expand-file-name (concat user-emacs-directory "elisp/brazil-holidays.el")))
(setq calendar-holidays holiday-brazil-all)

(load (expand-file-name (concat user-emacs-directory "sensitive/agenda.el")))
(add-hook 'org-mode-hook 'auto-revert-mode)
#+END_SRC
** Appearance
#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :config (progn (add-hook 'org-mode-hook (lambda () (org-superstar-mode 1)))))

(use-package fill-column-indicator
  :config (progn
            (add-hook 'org-mode-hook
                      (lambda ()
                        (setq fci-rule-width 1)
                        (setq fci-rule-color "darkblue")))
            (add-hook 'org-mode-hook 'turn-on-auto-fill)))

#+END_SRC
** Org Alert
#+BEGIN_SRC emacs-lisp
(use-package org-alert
  :config (progn
            (setq alert-default-style          'libnotify
                  org-alert-notification-title "*org-mode*"
                  org-alert-interval           21600)
            (org-alert-enable)))
#+END_SRC
** Exports and Org-Babel

Let's begin by setting up a few things for Babel.

#+begin_src emacs-lisp
(setq org-export-allow-bind-keywords t)

(use-package ob-go)
(use-package ess) ;; package for languages such as Julia, R
(org-babel-do-load-languages 'org-babel-load-languages
                             '((lisp   . t)
                               (go     . t)
                               (shell  . t)
                               (dot    . t)
                               (js     . t)
                               (julia  . t)
                               (C      . t)
                               (scheme . t)
                               (shen   . t)
                               (prolog . t)
                               (python . t)
                               (ein    . t)
                               (emacs-lisp . t)
                               (clojure . t)
                               (hy . y)
                               (restclient . t)
                               (plantuml . t)
                               (sql . t)))

(mapc (lambda (x)
        (add-to-list 'org-babel-tangle-lang-exts x))
      '(("js"      . "js")
        ("gnu-apl" . "apl")))
#+end_src
** HTMLize

Configure Htmlize to preferred defaults.

#+begin_src emacs-lisp
(use-package htmlize
  :config (setq htmlize-output-type 'css))
#+end_src
** LaTeX

#+begin_src emacs-lisp
(require 'ox-latex)
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))

(add-to-list 'org-latex-classes
             '("abntex2"
               "\\documentclass{abntex2}
                  [NO-DEFAULT-PACKAGES]
                  [EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
               ("\\maketitle" . "\\imprimircapa")))

(add-to-list 'org-latex-classes
             '("standalone"
               "\\documentclass{standalone}
                [NO-DEFAULT-PACKAGES]"))
#+end_src

I also like to use the plain PDF export.

#+begin_src emacs-lisp
(setq org-latex-pdf-process '("latexmk -shell-escape -bibtex -f -pdfxe -8bit %f"))
#+end_src

Also, for buffer images to scale and look good, we use this:

#+begin_src emacs-lisp
;;(plist-put org-format-latex-options :scale 1.2)
#+end_src

When using the =minted= package for source code, make sure that /Common
Lisp/ uses highlighting:

#+begin_src emacs-lisp
(setq org-latex-listings 'minted)
(add-to-list 'org-latex-minted-langs
             '(lisp "common-lisp"))
(add-to-list 'org-latex-packages-alist '("" "minted"))
#+end_src

=inputenc= configuration for Unicode characters.

#+begin_src emacs-lisp
(setq org-latex-inputenc-alist '(("utf8" . "utf8x")))
#+end_src

Using =mathletters= from =ucs= also helps a lot.

#+begin_src emacs-lisp
(add-to-list 'org-latex-default-packages-alist
             '("mathletters" "ucs" nil))
#+end_src
** Epub

Export Org filex to Epub format.

#+begin_src emacs-lisp
(use-package ox-epub)
#+end_src
** COMMENT Org Capture and Org Protocol

Org Protocol configures Emacs to deal properly with the Org Capture
extension for browsers.

Org protocol file location is stored in a sensitive file.

#+begin_src emacs-lisp
(require 'org-protocol)
(require 'org-capture)
(defun sqbrackets->rndbrackets (string)
  (concat (mapcar #'(lambda (c)
                      (cond ((equal c ?\[) ?\()
                            ((equal c ?\]) ?\))
                            (t c)))
                  string)))


(load-sensible-file "org-protocol.el")

(setq org-capture-templates
      `(("p"
         "Protocol" entry (file+headline ,org-capture-file "Inbox")
         ,(concat "* [[%:link][%(sqbrackets->rndbrackets \"%:description\")]]\n"
                  "#+begin_quote\n"
                  "%i\n"
                  "#+end_quote\n\n"
                  "Acesso em: %U\n\n"))
        ("L" "Protocol Link" entry (file+headline ,org-capture-file "Inbox")
         ,(concat "* [[%:link][%(sqbrackets->rndbrackets \"%:description\")]]\n"
                  "Acesso em: %U\n\n"))))
#+end_src

Here is an example of file, which you should store at, say,
=~/.local/share/applications/org-protocol.desktop=:

#+BEGIN_EXAMPLE
[Desktop Entry]
Name=org-protocol
Exec=emacsclient -c "%u"
Type=Application
Terminal=false
Categories=System;
MimeType=x-scheme-handler/org-protocol;
#+END_EXAMPLE

** COMMENT Org-ref

Org-ref is the best tool for managing bibliography.
Bibliography location is stored on a sensitive file.

#+begin_src emacs-lisp
  (use-package org-ref
    ;:config (progn
              ;(load-sensible-file "org-ref.el")
     ;         (require 'org-ref-pdf)
      ;        (require 'org-ref-bibtex)
       ;       (require 'org-ref-url-utils))
  )
#+end_src

I also need a different citation type to conform with ABNT rules. This
makes sure that ABNTeX2's =\citeonline{}= works.

#+begin_src emacs-lisp
;;(org-ref-define-citation-link "citeonline" ?o)
#+end_src

** Org Reveal.js
#+BEGIN_SRC emacs-lisp
(use-package org-re-reveal
  :init (setq org-reveal-mathjax t
              org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js@3.9.2/js/reveal.min.js"
              org-reveal-root "http://cdn.jsdelivr.net/reveal.js@3.9.2/"))

;; (require 'oer-reveal-publish)
;; (oer-reveal-setup-submodules t)
;; (oer-reveal-generate-include-files t)
;; (oer-reveal-publish-setq-defaults)

;(use-package org-re-reveal-ref)

(setq org-ref-default-bibliography '("references.bib")
      org-ref-bibliography-entry-format
      '(("article" . "%a, %t, <i>%j %v(%n)</i>, %p (%y). <a href=\"%U\">%U</a>")
        ("book" . "%a, %t, %u, %y. <a href=\"%U\">%U</a>")
        ("inproceedings" . "%a, %t, %b, %y. <a href=\"%U\">%U</a>")
        ("incollection" . "%a, %t, %b, %u, %y. <a href=\"%U\">%U</a>")
        ("misc" . "%a, %t, %i, %y.  <a href=\"%U\">%U</a>")
        ("phdthesis" . "%a, %t, %s, %y.  <a href=\"%U\">%U</a>")
        ("techreport" . "%a, %t, %i, %u (%y).")
        ("proceedings" . "%e, %t in %S, %u (%y).")
        ))
#+END_SRC
** Presentations

I use Epresentation which makes Emacs fullscreen in org.

#+begin_src emacs-lisp
(use-package epresent)
#+end_src
** Org-noter

Org-noter is a tool for writing notes in Org for PDFs, EPUB, DVI, PS,
etc. See the documentation [[https://github.com/weirdNox/org-noter][here]].

#+begin_src emacs-lisp
(use-package org-noter)
#+end_src

** COMMENT Org-roam

The variable =org-roam-directory= is determined in =sensitive/org-roam.el=.

#+begin_src emacs-lisp
(defconst personal-keybindings '())

(use-package org-roam
  :hook (after-init . org-roam-mode)
  :straight (:host github :repo "jethrokuan/org-roam" :branch "develop")
  :config (load-sensible-file "org-roam.el")
  :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n b" . org-roam-switch-to-buffer)
               ("C-c n g" . org-roam-show-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))))
#+end_src
** COMMENT Deft

Since I'm using Deft exclusively for =org-roam= stuff, I'll put it here.
It'll provide a nice interface for browsing and filtering notes.

#+begin_src emacs-lisp
(use-package deft
  :after org-roam
  :bind
  ("C-c n d" . deft)
  :custom
  (deft-recursive t)
  (deft-use-filter-string-for-filename t)
  (deft-default-extension "org")
  (deft-directory org-roam-directory))
#+end_src
** Org-journal

Org-journal is useful for keeping up notes on a journal.
My journal files are kept in a sensible file =sensitive/journal.el=.

#+begin_src emacs-lisp
;;(load-sensible-file "journal.el")

(defvar org-journal-loaded nil)

(use-package org-journal
  :init
  (defun org-journal-load-files ()
    (interactive)
    (when (not org-journal-loaded)
      (setq org-agenda-file-regexp "\\`[^.].*\\.org'\\|[0-9]$")
      (add-to-list 'org-agenda-files org-journal-dir)
      (setq org-journal-loaded t)))
  :config (setq org-journal-loaded nil
                org-agenda-include-diary t))

#+end_src

** Org Crypt
#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key "9CD4DA20")

;;(use-package org-web-tools :ensure t)
#+END_SRC
* Calfw
#+BEGIN_SRC emacs-lisp
(use-package calfw)

(use-package calfw-org
  :requires calfw)

(use-package calfw-cal
  :config
  ;; Month
  (progn
    (setq cfw:org-overwrite-default-keybinding t)
    (global-set-key (kbd "<f6>")
                    (lambda ()
                      (interactive)
                      (cfw:open-org-calendar)))
    (setq calendar-month-name-array ["January" "February" "March"     "April"   "May"      "June"
                                    "July"    "August"   "September" "October" "November" "December"]
         calendar-day-name-array ["Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday"]
         calendar-week-start-day 1)
    (custom-set-faces
     '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
     '(cfw:face-header ((t (:foreground "#d0bf8f" :weight bold))))
     '(cfw:face-sunday ((t :foreground "#cc9393" :background "grey10" :weight bold)))
     '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "grey10" :weight bold)))
     '(cfw:face-holiday ((t :background "grey10" :foreground "#8c5353" :weight bold)))
     '(cfw:face-grid ((t :foreground "DarkGrey")))
     '(cfw:face-default-content ((t :foreground "#bfebbf")))
     '(cfw:face-periods ((t :foreground "cyan")))
     '(cfw:face-day-title ((t :background "grey10")))
     '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
     '(cfw:face-annotation ((t :foreground "RosyBrown" :inherit cfw:face-day-title)))
     '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
     '(cfw:face-today-title ((t :background "#7f9f7f" :weight bold)))
     '(cfw:face-today ((t :background: "grey10" :weight bold)))
     '(cfw:face-select ((t :background "#2f2f2f")))
     '(cfw:face-toolbar ((t :foreground "Steelblue4" :background "Steelblue4")))
     '(cfw:face-toolbar-button-off ((t :foreground "Gray10" :weight bold)))
     '(cfw:face-toolbar-button-on ((t :foreground "Gray50" :weight bold))))))
(use-package calfw-ical)
(use-package calfw-org)


(defun my-open-calendar ()
  (interactive)
  (cfw:open-calendar-buffer
   :contents-sources
   (list
    (cfw:org-create-source "Green")  ; orgmode source
    ;(cfw:howm-create-source "Blue")  ; howm source
    (cfw:cal-create-source "Orange") ; diary source
    ;(cfw:ical-create-source "Moon" "~/moon.ics" "Gray")  ; ICS source1
    ;(cfw:ical-create-source "gcal" "https://..../basic.ics" "IndianRed") ; google calendar ICS
   )))
#+END_SRC
* Dashboard
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook)
  (progn
    (setq initial-buffer-choice (lambda ()
                                  (get-buffer "*dashboard*"))
          dashboard-center-content t
          dashboard-startup-banner 'logo
          dashboard-set-navigator t
          dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5)
                            (registers . 5)))))
#+END_SRC
* Tramp
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
    :ensure t
    :bind("s-e" . sudo-edit))

(use-package counsel-tramp
  :config (setq tramp-default-method "ssh"))

(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC
* Iedit and narrow/widen dwin
#+BEGIN_SRC emacs-lisp
; mark and edit all copies of the marked region simultaniously.
(use-package iedit
  :ensure t)

; if you're windened, narrow to the region, if you're narrowed, widen
; bound to C-x n
(defun narrow-or-widen-dwim (p)
"If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
Intelligently means: region, org-src-block, org-subtree, or defun,
whichever applies first.
Narrowing to org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is already
narrowed."
(interactive "P")
(declare (interactive-only))
(cond ((and (buffer-narrowed-p)
            (not p))
       (widen))
      ((region-active-p)
       (narrow-to-region (region-beginning) (region-end)))
      ((derived-mode-p 'org-mode)
       ;; `org-edit-src-code' is not a real narrowing command.
       ;; Remove this first conditional if you don't want it.
       (cond ((ignore-errors (org-edit-src-code))
              (delete-other-windows))
             ((org-at-block-p)
              (org-narrow-to-block))
             (t (org-narrow-to-subtree))))
      (t (narrow-to-defun))))
#+END_SRC
* Try
- Try is a package that allows you to try out Emacs packages without installing them. If you pass a URL to a plain text .el-file it evaluates the content, without storing the file.
#+BEGIN_SRC emacs-lisp
(use-package try
    :ensure t)
#+END_SRC

* Which key
#+BEGIN_SRC emacs-lisp
(use-package which-key
         :config
         (which-key-mode))
#+END_SRC
* Better Shell
#+BEGIN_SRC emacs-lisp
(use-package better-shell
  :ensure t
  :bind (("C-\"" . better-shell-shell)
         ("C-:" . better-shell-remote-open)))

(use-package shell
  :ensure nil
  :commands comint-send-string comint-simple-send comint-strip-ctrl-m
  :preface
  (defun n-shell-simple-send (proc command)
    "Various PROC COMMANDs pre-processing before sending to shell."
    (cond
     ;; Checking for clear command and execute it.
     ((string-match "^[ \t]*clear[ \t]*$" command)
      (comint-send-string proc "\n")
      (erase-buffer))
     ;; Checking for man command and execute it.
     ((string-match "^[ \t]*man[ \t]*" command)
      (comint-send-string proc "\n")
      (setq command (replace-regexp-in-string "^[ \t]*man[ \t]*" "" command))
      (setq command (replace-regexp-in-string "[ \t]+$" "" command))
      ;;(message (format "command %s command" command))
      (funcall 'man command))
     ;; Send other commands to the default handler.
     (t (comint-simple-send proc command))))
  (defun n-shell-mode-hook ()
    "Shell mode customizations."
    (local-set-key '[up] 'comint-previous-input)
    (local-set-key '[down] 'comint-next-input)
    (local-set-key '[(shift tab)] 'comint-next-matching-input-from-input)
    (setq comint-input-sender 'n-shell-simple-send))
  :hook ((shell-mode . ansi-color-for-comint-mode-on)
         (shell-mode . n-shell-mode-hook))
  :config
  (setq system-uses-terminfo nil)       ; don't use system term info

  (add-hook 'comint-output-filter-functions #'comint-strip-ctrl-m)

  ;; Company mode backend for shell functions
  (use-package company-shell
    :after company
    :init (cl-pushnew '(company-shell company-shell-env company-fish-shell)
                      company-backends))

  ;; Bash completion
  (use-package bash-completion
    :init (bash-completion-setup))

  ;; ANSI & XTERM 256 color support
  (use-package xterm-color
    :defines compilation-environment
    :init
    (setenv "TERM" "xterm-256color")
    (setq comint-output-filter-functions
          (remove 'ansi-color-process-output comint-output-filter-functions))

    (add-hook 'shell-mode-hook
              (lambda () (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))))

#+END_SRC
* Keyfreq
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :config
  (require 'keyfreq)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1))
#+END_SRC
* Version Control Systems
** Ediff
Sane config for =ediff= which is basically removing noisy
highlights, avoiding crazy multi-frames setup, ignoring some
whitespaces and windows should be side-by-side.

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :init
  (setq ediff-highlight-all-diffs nil)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-diff-options "-w")
  (setq ediff-split-window-function 'split-window-horizontally))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :bind ("C-x g" . magit-status)
  :init
  (setq magit-diff-options (quote ("--word-diff"))
        magit-diff-refine-hunk 'all
        ;;magit-completing-read-function 'magit-ido-completing-read
        ;; highlight individual word and letter changes when hunk diff displays
        magit-diff-refine-hunk t
        ;; don't tell me when magit reverts buffers
        magit-revert-buffers 'silent
        ;; always show the verbose diff in commit windows
        magit-commit-arguments '("--verbose")
        ;; timeout when magit takes a while to call out to git
        magit-process-popup-time 10)
  :config
  (add-to-list 'magit-no-confirm 'stage-all-changes)
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))

(use-package magit-gitflow)

(use-package git-gutter
  :ensure t
  :init
  (global-git-gutter-mode +1))

(use-package browse-at-remote :ensure t)
(use-package gitconfig-mode :ensure t)
(use-package gitignore-templates :ensure t)
#+END_SRC
*** Gitconfig
[[https://github.com/magit/git-modes][gitconfig]] is a major mode for editing =gitconfig= files.
#+BEGIN_SRC emacs-lisp
(use-package gitconfig-mode
  :config
  (require 'gitconfig-mode))
#+END_SRC
*** Gitignore
[[https://github.com/magit/git-modes][git-modes]] has a major mode for editing =gitignore= files.
#+BEGIN_SRC emacs-lisp
(use-package gitignore-mode
  :config
  (require 'gitignore-mode))
#+END_SRC

** Time machine

    #+begin_src emacs-lisp
      (use-package git-timemachine :ensure t)
    #+end_src
** Visual identification
Show differences between local and remote repo.
 #+BEGIN_SRC emacs-lisp
 (use-package diff-hl
   :init
   (setq diff-hl-side 'left)
   :config
   (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
   (diff-hl-flydiff-mode)
   (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
   (global-diff-hl-mode)

   (custom-set-faces
    '(diff-hl-change ((t (:background "#3a81c3"))))
    '(diff-hl-insert ((t (:background "#7ccd7c"))))
    '(diff-hl-delete ((t (:background "#ee6363"))))))
#+END_SRC
** Undo Tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :bind (("C-x u" . undo-tree-visualize)
         ("C-_" . undo)
         ("M-_" . undo-tree-redo))
  :config ;; autosave the undo-tree history
  (progn
   (setq undo-tree-history-directory-alist `((".*" . ,temporary-file-directory))
         undo-tree-auto-save-history t)
   (global-undo-tree-mode 1)))
#+END_SRC
** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
      :ensure t
      :bind ("C-c p" . projectile-command-map)
      :config
      (projectile-global-mode)
      (setq projectile-completion-system 'ivy)
      (progn (projectile-mode +1)
                 (define-key projectile-mode-map
                   (kbd "C-c p") 'projectile-command-map)
                 (add-to-list
                  'projectile-globally-ignored-directories
                  "node_modules")))
#+END_SRC
This is for Projectile usage with Ivy/Counsel.

#+begin_src emacs-lisp
(use-package counsel-projectile
  :config (counsel-projectile-mode))
#+end_src
* Searchers
** Wgrep

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep
       :ensure t)
   #+END_SRC

** Ripgrep
#+BEGIN_SRC emacs-lisp
(use-package projectile-ripgrep)
(use-package rg
  :ensure t
  :config
  (rg-define-search bk/search-git-root-or-dir
    :query ask
    :format regexp
    :files "everything"
    :dir (let ((vc (vc-root-dir)))
           (if vc
               vc
               default-directory))
          :confirm prefix
          :flags ("--hidden -g !.git"))
;;        :bind ("M-s g" . bk/search-git-root-or-DIR)
)
    #+END_SRC
** Occur

   Let's use an =occur= snippet from [[https://oremacs.com/2015/01/26/occur-dwim/][(or emacs]]. It will offer as the
   default candidate:
   - the current region, if it's active
   - the current symbol, otherwise

   #+BEGIN_SRC emacs-lisp
     (defun occur-dwim ()
       "Call `occur' with a sane default."
       (interactive)
       (push (if (region-active-p)
                 (buffer-substring-no-properties
                  (region-beginning)
                  (region-end))
               (let ((sym (thing-at-point 'symbol)))
                 (when (stringp sym)
                   (regexp-quote sym))))
             regexp-history)
       (call-interactively 'occur))

     (global-set-key (kbd "M-s o") 'occur-dwim)
   #+END_SRC

** COMMENT Google this

   Artur Malabarba has a nice package called =google-this= which
   provides a set of functions for querying google from emacs.

   #+BEGIN_SRC emacs-lisp
     (use-package google-this
       :delight google-this-mode
       :config
       (google-this-mode 1))
   #+END_SRC

   This package provides a set of functions under the prefix =C-c /=.
   The simplest is =C-c / RET= which prompts you for a search in the
   minibuffer, with a default search based on the text around the
   point.

   | Keys           | Function                              |
   |----------------+---------------------------------------|
   | C-c / SPC      | google-this-region                    |
   | C-c / a        | google-this-ray                       |
   | C-c / c        | google-this-translate-query-or-region |
   | C-c / e        | google-this-error                     |
   | C-c / f        | google-this-forecast                  |
   | C-c / g        | google-this-lucky-search              |
   | C-c / i        | google-this-lucky-and-insert-url      |
   | C-c / m        | google-maps                           |
   | C-c / n        | google-this-noconfirm                 |
   | C-c / r        | google-this-cpp-reference             |
   | C-c / s        | google-this-symbol                    |
   | C-c / t        | google-this                           |
   | C-c / w        | google-this-word                      |
   | C-c / <return> | google-this-search                    |

* COMMENT PDF Tools
#+BEGIN_SRC emacs-lisp
(when (not (eq system-type 'darwin))
  (use-package pdf-tools
  :config (progn (pdf-tools-install)
                 ;;(add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode)
                 (setq pdf-annot-activate-created-annotations t)
                 (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
                 ;; turn off cua so copy works
                 (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
                 ;; more fine-grained zooming
                 (setq pdf-view-resize-factor 1.1)
                 ;; keyboard shortcuts
                 (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
                 (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
                 (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete)
                 (add-hook 'pdf-view-mode-hook 'pdf-view-fit-height-to-window)
                 (add-hook 'pdf-view-mode-hook 'auto-revert-mode)))
  ;; initialise
  ;; open pdfs scaled to fit page

  ;; automatically annotate highlights

  ;; use normal isearch
  )
#+END_SRC
* Regex
#+BEGIN_SRC emacs-lisp
(use-package pcre2el
  :ensure t
  :config (pcre-mode))
#+END_SRC
* Media
** EMMS with mpd
There is many backends, many players and codecs for EMMS, we use mpd now.
*** Basic setup for mpd
The non XF86 keys are made to be somewhat logical to follow and easy to remember.
At the bottom part of the configuration, you will notice how XF86 keys are used
by default, so unless you keyboard is broken it should work out of the box.
Obviously you might have to adjust /server-name/ and /server-port/ to fit your configuration.
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :ensure t
    :config
      (require 'emms-setup)
      (require 'emms-player-mpd)
      (emms-all) ; don't change this to values you see on stackoverflow questions if you expect emms to work
      (setq emms-seek-seconds 5)
      (setq emms-player-list '(emms-player-mpd))
      (setq emms-info-functions '(emms-info-mpd))
      (setq emms-player-mpd-server-name "localhost")
      (setq emms-player-mpd-server-port "6601")
    :bind
      ("s-m p" . emms)
      ("s-m b" . emms-smart-browse)
      ("s-m r" . emms-player-mpd-update-all-reset-cache)
      ("<XF86AudioPrev>" . emms-previous)
      ("<XF86AudioNext>" . emms-next)
      ("<XF86AudioPlay>" . emms-pause)
      ("<XF86AudioStop>" . emms-stop))
#+END_SRC

*** MPC Setup
**** Setting the default port
We use non-default settings for the socket, to use the built in =mpc= functionality we need to set up a variable.
Adjust according to your setup.
#+BEGIN_SRC emacs-lisp
  (setq mpc-host "localhost:6601")
#+END_SRC

*** Some more fun stuff
**** Starting the daemon from within emacs
If you have an absolutely massive music library, it might be a good idea to get rid of =mpc-update=
and only invoke it manually when needed.
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connects to it and syncs the metadata cache."
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD Started!"))
  (global-set-key (kbd "s-m c") 'mpd/start-music-daemon)
#+END_SRC

**** Killing the daemon from within emacs
#+BEGIN_SRC emacs-lisp
  (defun mpd/kill-music-daemon ()
    "Stops playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed!"))
  (global-set-key (kbd "s-m k") 'mpd/kill-music-daemon)
#+END_SRC
**** Updating the database easily.
#+BEGIN_SRC emacs-lisp
  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated!"))
  (global-set-key (kbd "s-m u") 'mpd/update-database)
#+END_SRC
* COMMENT Slack
Configuring Slack client.

Sensible stuff goes into =sensitive/slack.el=.

#+begin_src emacs-lisp
(use-package slack
  :commands (slack-start)
  :init
  (setq slack-buffer-emojify      t
        slack-prefer-current-team t)
  :config (load-sensible-file "slack.el"))

(el-get-bundle yuya373/helm-slack)
(require 'helm-slack)
(global-set-key (kbd "C-c n s") #'helm-slack)
#+end_src

We use the =alert= package for notifications.

#+begin_src emacs-lisp
(use-package alert
  :commands (alert)
  :init (setq alert-default-style 'notifier))
#+end_src
* COMMENT ORG Jira
#+BEGIN_SRC emacs-lisp
(defconst org-jira-progress-issue-flow
  '(("To Do" . "Start Progress")
    ("In Development" . "Ready For Review")
    ("Code Review" . "Done")
    ("Done" . "Reopen")))

(use-package org-jira
  :config
  (setq jiralib-url "https://paygo.atlassian.net/")
  (define-key org-jira-map (kbd "C-c pg") 'org-jira-get-projects)
  (define-key org-jira-map (kbd "C-c ib") 'org-jira-browse-issue)
  (define-key org-jira-map (kbd "C-c ig") 'org-jira-get-issues)
  (define-key org-jira-map (kbd "C-c ij") 'org-jira-get-issues-from-custom-jql)
  (define-key org-jira-map (kbd "C-c ih") 'org-jira-get-issues-headonly)
  (define-key org-jira-map (kbd "C-c iu") 'org-jira-update-issue)
  (define-key org-jira-map (kbd "C-c iw") 'org-jira-progress-issue)
  (define-key org-jira-map (kbd "C-c in") 'org-jira-progress-issue-next)
  (define-key org-jira-map (kbd "C-c ia") 'org-jira-assign-issue)
  (define-key org-jira-map (kbd "C-c ir") 'org-jira-refresh-issue)
  (define-key org-jira-map (kbd "C-c iR") 'org-jira-refresh-issues-in-buffer)
  (define-key org-jira-map (kbd "C-c ic") 'org-jira-create-issue)
  (define-key org-jira-map (kbd "C-c ik") 'org-jira-copy-current-issue-key)
  (define-key org-jira-map (kbd "C-c sc") 'org-jira-create-subtask)
  (define-key org-jira-map (kbd "C-c sg") 'org-jira-get-subtasks)
  (define-key org-jira-map (kbd "C-c cc") 'org-jira-add-comment)
  (define-key org-jira-map (kbd "C-c cu") 'org-jira-update-comment)
  (define-key org-jira-map (kbd "C-c wu") 'org-jira-update-worklogs-from-org-clocks)
  (define-key org-jira-map (kbd "C-c tj") 'org-jira-todo-to-jira)
  (define-key org-jira-map (kbd "C-c if") 'org-jira-get-issues-by-fixversion))
#+END_SRC
* Telega
#+BEGIN_SRC emacs-lisp
(use-package telega
  :config (progn
            (telega-notifications-mode 1) ; DBus notifications
            (setq telega-use-images t))
  :hook ((telega-chat-mode-hook
          .
          (lambda () ; completions
            (set (make-local-variable 'company-backends)
                 (append '(telega-company-emoji
                           telega-company-username
                           telega-company-hashtag)
                         (when (telega-chat-bot-p telega-chatbuf--chat)
                           '(telega-company-botcmd))))
            (company-mode 1)))))
#+END_SRC
* COMMENT Wakatime
#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :ensure t
  :config
  (setq wakatime-api-key ""))
#+END_SRC
* nov.el

Nov.el is good for reading EPUB files on Emacs.

Oh, and I also use Olivetti for centering and making it look good.

#+begin_src emacs-lisp
  (use-package nov
    :config (progn
              (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
              (add-hook 'nov-mode-hook
                        (lambda ()
                          (face-remap-add-relative 'variable-pitch
                                                   :family "Liberation Serif"
                                                   :height 1.0)))
              (add-hook 'nov-mode-hook (lambda () (olivetti-mode 1)))
              (setq nov-text-width 80)))
#+end_src
* COMMENT Mu4e

Mu4e is my favorite e-mail application. Fortunately, it can be
installed from my distribution's package manager.

Personal stuff should be in =sensitive/mail.el=.

#+begin_src emacs-lisp
(when (eq system-type 'gnu/linux)
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")

  (require 'mu4e)
  (require 'smtpmail)

  (use-package mu4e-alert
    :config (progn
              (mu4e-alert-set-default-style 'libnotify)
              (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
              (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)))

  (setq mail-user-agent                   'mu4e-user-agent
        message-send-mail-function        'smtpmail-send-it
        message-kill-buffer-on-exit       t
        mu4e-change-filenames-when-moving t
        mu4e-view-show-images             t)

  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))

  (load-sensible-file "mail.el"))
#+end_src

Let's make sure that mu4e messages wrap on column 80, just like Org. I
also like the usage of format=flowed.

#+begin_src emacs-lisp
(add-hook 'message-mode-hook 'auto-fill-mode)
(setq mu4e-compose-format-flowed t)
#+end_src
** Extra configuration

I think it is interesting to describe other stuff I did here. I use
ProtonMail Bridge to help me manage my mail, and it is synced using
=mbsync=. To make it work, it is important to have some more
configuration.

Here is my =.mbsyncrc= file.

#+begin_example
IMAPAccount protonmail
Host 127.0.0.1
Port PROTONMAIL-BRIDGE-GIVEN-IMAP-PORT
User mymail@example.com
PassCmd "gpg2 -q -d /path/to/authinfo.gpg | awk 'FNR == 1 {print $8}'"
SSLType NONE

IMAPStore remote
Account protonmail

MaildirStore local
Subfolders Verbatim
Path  /path/to/my/mail/box
Inbox /path/to/my/mail/box/INBOX/

Channel inbox
Master :remote:
Slave :local:
Patterns * !"Drafts" !"All Mail"
Create Slave
SyncState *
Sync All
Expunge Both

Group protonmail
Channel inbox
#+end_example

Oh, and Bridge can be a real bitch when handling your passwords, since
it requires =pass= or =gnome-keyring=; I use the latter. Also, make sure
you have DBus working (yeah, I know, I know. DBus sucks).

And here is how I defined my Mu4e context for ProtonMail. I have
omitted the sensitive parts, but this should give you a heads-up on
how to setup the =mu4e-contexts= variable.

#+begin_src emacs-lisp :tangle no
;; This code snippet SHOULD NOT BE TANGLED with the rest of the
;; configuration. Edit the sensitive/mail.el file if you need
;; to modify this code.

(setq mu4e-compose-signature "My Awesome Signature"
      mu4e-maildir-shortcuts '(("/INBOX"   . ?i)
                               ("/Sent"    . ?s)
                               ("/Drafts"  . ?d)
                               ("/Archive" . ?a)
                               ("/Trash"   . ?t)))

(setq mu4e-contexts
      `(,(make-mu4e-context
          :name "Protonmail"
          :vars
          `((mu4e-maildir          . ,(expand-file-name "/path/to/my/mail/box"))
            (user-mail-address     . "mymail@example.com")
            (user-full-name        . "My Name")
            (mu4e-attachment-dir   . "/path/to/attachment/download/dir")
            (mu4e-trash-folder     . "/Trash")
            (mu4e-refile-folder    . "/Archive")
            (mu4e-drafts-folder    . "/Drafts")
            (mu4e-sent-folder      . "/Sent")
            (mu4e-get-mail-command . "mbsync protonmail")
            (smtpmail-smtp-user    . "mymail@example.com")
            (smtpmail-stream-type  . starttls)
            (smtpmail-auth-credentials . "/path/to/authinfo.gpg")
            (smtpmail-smtp-server  . "127.0.0.1")
            (smtpmail-smtp-service . PROTONMAIL-BRIDGE-GIVEN-SMTP-PORT)))))
#+end_src

* COMMENT Elfeed

Elfeed is an RSS/Atom feed reader. The location of the Elfeed file is
kept in a sensitive file.

#+begin_src emacs-lisp
(load-sensible-file "elfeed.el")
(use-package elfeed-org)
(use-package elfeed
  :requires elfeed-org
  :config (progn
            (elfeed-org)
            (setq-default elfeed-search-filter "@3-days-ago +unread ")
            ;; Move forward and backward
            (define-key elfeed-show-mode-map (kbd "C-<right>") 'elfeed-show-next)
            (define-key elfeed-show-mode-map (kbd "C-<left>") 'elfeed-show-prev)
            (define-key elfeed-show-mode-map (kbd "k") 'elfeed-show-next)
            (define-key elfeed-show-mode-map (kbd "j") 'elfeed-show-prev)))
#+end_src

Let's add some goodies.

#+begin_src emacs-lisp
(use-package elfeed-goodies
  :config (elfeed-goodies/setup))
#+end_src
* COMMENT Ivy-Spotify

Controlling Spotify from Emacs/Dashboard (via dbus) uses an Ivy interface.

#+begin_src emacs-lisp
;;(use-package ivy-spotify) ; unavailable!
#+end_src

Then set the variables =counsel-spotify-client-id= and
=counsel-spotify-client-secret=.

If Emacs cannot access =dbus= (or Spotify is not recognized by =dbus=), it
may be interesting to have a script to invoke Emacs as follows (which
can be adapted into Spotify's):

#+begin_src bash :tangle no
#!/bin/bash

source $HOME/.dbus/session-bus/*
export DBUS_SESSION_BUS_ADDRESS
export DBUS_SESSION_BUS_PID
emacs --daemon &
#+end_src

Everything regarding the WM or DE-like functionality is bundled here, remove the entire section if you do not wish to use =exwm=.
* Paradox

#+begin_src emacs-lisp
(use-package paradox
  :config (paradox-enable))
#+end_src

#+begin_src emacs-lisp
#+end_src

* Mingus

Mingus controls MPD.

#+begin_src emacs-lisp
(use-package mingus)
#+end_src

* EMMS

Here we configure EMMS by using the MPV backend.

#+begin_src emacs-lisp
(use-package emms
  :config
  (progn (require 'emms-setup)
         (require 'emms-player-mpv)
         (emms-all)
         (setq emms-seek-seconds           5
               emms-player-list            '(emms-player-mpv)
               emms-info-functions         '(emms-info-cueinfo
                                             emms-info-ogginfo
                                             emms-info-mp3info
                                             emms-info-metaflac)
               emms-browser-covers         'emms-browser-cache-thumbnail)
         (add-to-list 'emms-player-mpv-parameters "--no-audio-display"))
  :bind
  ("<XF86AudioPrev>" . emms-previous)
  ("<XF86AudioNext>" . emms-next)
  ("<XF86AudioPlay>" . emms-pause)
  ("<XF86AudioStop>" . emms-stop))
#+end_src

* EXWM

Configuration for EXWM.

#+begin_src emacs-lisp
(defconst *use-exwm* t)

(defmacro with-exwm (&rest body)
  `(when *use-exwm*
     ,@body))
#+end_src

We begin with installation. I'm gonna assume EXWM is installed for the
configuration that follows; to deactivate EXWM, just add a =COMMENT=
directive to this topic so it doesn't tangle.

#+begin_src emacs-lisp
(with-exwm
 (use-package exwm
   :config (progn (require 'exwm-config)
                  (exwm-config-default))))
#+end_src

Require packages at start.

#+begin_src emacs-lisp
(with-exwm
 (require 'exwm)
 (require 'exwm-config))
#+end_src

Also enable time on modeline.

#+begin_src emacs-lisp
(with-exwm
 (setq display-time-default-load-average nil
       display-time-day-and-date t
       display-time-24hr-format  t)
 (display-time-mode t))
#+end_src

Finally, start the Emacs server.

#+begin_src emacs-lisp
(with-exwm
 (server-start))
#+end_src

** Workspaces

Initial number of buffers is 9, which works fine for me on bspwm as
well.

#+begin_src emacs-lisp
(with-exwm
 (setq exwm-workspace-number 9))
#+end_src

** Buffer naming

Buffers created in EXWM should be named after their X window class
name or title. Java applications and GIMP use window titles due to
multiple windows.

#+begin_src emacs-lisp
(with-exwm
 (add-hook 'exwm-update-class-hook
           (lambda ()
             (unless (or (string-prefix-p "sun-awt-x11-" exwm-instance-name)
                         (string= "gimp" exwm-instance-name))
               (exwm-workspace-rename-buffer exwm-class-name))))

 (add-hook 'exwm-update-title-hook
           (lambda ()
             (when (or (not exwm-instance-name)
                       (string-prefix-p "sun-awt-x11-" exwm-instance-name)
                       (string= "gimp" exwm-instance-name))
               (exwm-workspace-rename-buffer exwm-title)))))
#+end_src

** Utilities

#+begin_src emacs-lisp
(with-exwm
 (defun my-exec-async (command)
   (start-process-shell-command command nil command)))
#+end_src

#+begin_src emacs-lisp
(with-exwm
 (cl-labels ((workspace-switch (transform)
              (let ((ws-num (% (funcall transform
                                        exwm-workspace-current-index)
                               exwm-workspace-number)))
                (exwm-workspace-switch
                 (if (< ws-num 0)
                     (1- exwm-workspace-number)
                   ws-num)))))
   (defun my-exwm-next-workspace ()
     (interactive)
     (workspace-switch #'1+))

   (defun my-exwm-prev-workspace ()
     (interactive)
     (workspace-switch #'1-))))
#+end_src

#+begin_src emacs-lisp
(with-exwm
 (defun my-control-volume (action)
   (when (member action '(:up :down :toggle))
     (my-exec-async "dzvol -bg \"#14171e\"")
     (case action
       (:up     (my-exec-async "amixer set Master 2%+"))
       (:down   (my-exec-async "amixer set Master 2%-"))
       (:toggle (my-exec-async "amixer set Master toggle"))))))
#+end_src

** Global keys

Here are some examples of keybindings.

#+begin_src emacs-lisp
(with-exwm
 (setq exwm-input-global-keys
       ;; switch to line-mode, exit fullscreen, refresh etc
       `(([?\s-r] . exwm-reset)
         ;; Switch workspace
         ([?\s-w] . exwm-workspace-switch) ; switch workspace
         ;; Launch command without output. Either use s-& or s-SPC.
         ;; With output is M-&.
         ([?\s-&] . (lambda (command)
                      (interactive (list (read-shell-command "$ ")))
                      (my-exec-async command)))
         (,(kbd "s-SPC") . (lambda (command)
                             (interactive
                              (list (read-shell-command "$ ")))
                             (my-exec-async command)))
         ;; Previous/Next workspace
         ([?\s-a] . my-exwm-prev-workspace)
         ([?\s-d] . my-exwm-next-workspace)
         ([?\s-s] . exwm-floating-toggle-floating)
         (,(kbd "<XF86AudioRaiseVolume>")
          . (lambda ()
              (interactive)
              (my-control-volume :up)))
         (,(kbd "<XF86AudioLowerVolume>")
          . (lambda ()
              (interactive)
              (my-control-volume :down)))
         (,(kbd "<XF86AudioMute>")
          . (lambda ()
              (interactive)
              (my-control-volume :toggle))))))
#+end_src

** System Tray

#+begin_src emacs-lisp
(with-exwm
 (require 'exwm-systemtray)
 (exwm-systemtray-enable))
#+end_src

** Execute stuff on startup

Title says all! Can't live without my stuff.

#+begin_src emacs-lisp
(with-exwm
 (add-hook 'exwm-init-hook
           (lambda ()
             (mapc #'my-exec-async
                   '(;; Composition
                     "compton"
                     ;; Wallpaper
                     "hsetroot -fill ~/pictures/Wallpapers/corona-beach.jpg"
                     ;; NetworkManager applet
                     "nm-applet"
                     ;; Audio applet
                     ;;"pa-applet"
                     ;; Cursor
                     "xsetroot -cursor-name left_ptr"
                     ;; Keyboard layout applet
                     "fbxkb"
                     ;; Keybase daemon
                     "keybase ctl start"
                     ;; KBFS
                     "KEYBASE_RUN_MODE=prod kbfsfuse /keybase")))))
#+end_src

I also want to switch to workspace 0 and use the dashboard buffer.

#+begin_src emacs-lisp
(with-exwm
 (add-hook 'exwm-init-hook
           (lambda ()
             (exwm-workspace-switch 0))))
#+end_src
